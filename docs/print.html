<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>StylusPort::Solana</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">StylusPort::Solana</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This handbook provides a comprehensive guide for migrating Solana programs to Arbitrum Stylus smart contracts. This guide helps you understand the key differences and provides practical patterns for successful migration.</p>
<h2 id="what-arbitrum-stylus-offers"><a class="header" href="#what-arbitrum-stylus-offers">What Arbitrum Stylus offers</a></h2>
<p>Arbitrum Stylus provides a smart contract platform that supports developers writing contracts in Rust, C, and C++. The platform maintains full Ethereum Virtual Machine (EVM) compatibility. Unlike most EVM chains that require programming contracts with DSLs like Solidity or Vyper, Stylus enables the use of languages that compile to WebAssembly (WASM), offering:</p>
<ul>
<li><strong>Performance</strong>: 10-100x faster execution than Solidity</li>
<li><strong>Memory efficiency</strong>: More efficient memory usage and lower gas costs</li>
<li><strong>Familiar languages</strong>: Use Rust, C, C++ and other mainstream languages and tooling instead of coping with Solidity</li>
<li><strong>EVM compatibility</strong>: Full interoperability with existing Ethereum tooling</li>
</ul>
<h2 id="why-migrate-from-solana-to-stylus"><a class="header" href="#why-migrate-from-solana-to-stylus">Why migrate from Solana to Stylus</a></h2>
<h3 id="technical-advantages"><a class="header" href="#technical-advantages">Technical advantages</a></h3>
<ul>
<li><strong>Shared Language</strong>: Both Solana and Stylus support Rust, reducing the learning curve and enabling code reuse of business logic, data structures, and algorithms.</li>
<li><strong>Enhanced Interoperability</strong>: Stylus contracts can interact seamlessly with the broader Ethereum ecosystem, including DeFi protocols, bridges, and tooling.</li>
<li><strong>Simplified Architecture</strong>: The EVM account model reduces complexity compared to Solana's account model in state management and cross-contract interactions.</li>
</ul>
<h3 id="business-benefits"><a class="header" href="#business-benefits">Business benefits</a></h3>
<ul>
<li><strong>Market Access</strong>: Tap into Ethereum's large user base and liquidity pools</li>
<li><strong>Tooling Ecosystem</strong>: Leverage mature development tools and infrastructure</li>
<li><strong>EVM Compatibility</strong>: Easy integration with existing Ethereum protocols and services</li>
</ul>
<h2 id="key-differences-overview"><a class="header" href="#key-differences-overview">Key differences overview</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Solana</th><th>Stylus</th></tr></thead><tbody>
<tr><td><strong>Language</strong></td><td>Rust (native/Anchor)</td><td>Rust + EVM compatibility</td></tr>
<tr><td><strong>Account Model</strong></td><td>Explicit accounts</td><td>EVM account model</td></tr>
<tr><td><strong>State Storage</strong></td><td>Account data</td><td>Contract storage</td></tr>
<tr><td><strong>Function Calls</strong></td><td>Instructions</td><td>Direct method calls</td></tr>
<tr><td><strong>Gas Model</strong></td><td>Compute units</td><td>Wei/Gas</td></tr>
<tr><td><strong>Concurrency</strong></td><td>High (parallel execution)</td><td>Sequential (EVM)</td></tr>
</tbody></table>
</div>
<h2 id="development-environment-setup"><a class="header" href="#development-environment-setup">Development environment setup</a></h2>
<p>Before starting your migration, set up your development environment according to the <a href="https://docs.arbitrum.io/stylus/quickstart">official documentation</a>.</p>
<h2 id="project-structure-comparison"><a class="header" href="#project-structure-comparison">Project structure comparison</a></h2>
<p>Understanding the typical project structures helps you organize your migration:</p>
<h3 id="solana-native-project"><a class="header" href="#solana-native-project">Solana native project</a></h3>
<pre><code>solana-program/
├── Cargo.toml
├── src/
│   ├── lib.rs          # Program entrypoint
│   ├── processor.rs    # Instruction processing
│   ├── instruction.rs  # Instruction definitions
│   ├── state.rs        # Account state structures
│   └── error.rs        # Program errors
└── tests/
    └── integration.rs
</code></pre>
<h3 id="anchor-project"><a class="header" href="#anchor-project">Anchor project</a></h3>
<pre><code>anchor-program/
├── Anchor.toml
├── programs/
│   └── my-program/
│       ├── Cargo.toml
│       └── src/
│           └── lib.rs   # All-in-one program file
├── tests/
└── migrations/
</code></pre>
<h3 id="stylus-project"><a class="header" href="#stylus-project">Stylus project</a></h3>
<pre><code>stylus-contract/
├── Cargo.toml
├── src/
│   ├── lib.rs          # Contract implementation
│   └── main.rs         # ABI export entry point
└── tests/
    └── integration.rs
</code></pre>
<h2 id="migration-strategy"><a class="header" href="#migration-strategy">Migration strategy</a></h2>
<p>This handbook follows a systematic approach:</p>
<ol>
<li><a href="./program-structure.html">Program Structure Migration</a>: Convert entry points and instruction dispatch</li>
<li><a href="./state-storage.html">State Storage Patterns</a>: Transform account-based storage to contract storage</li>
<li><a href="./access-control.html">Access Control Migration</a>: Migrate signer checks and PDA patterns</li>
<li><a href="./external-calls.html">External Program Calls</a>: Convert CPIs to contract interactions</li>
<li><a href="./native-tokens.html">Native Token Operations</a>: Handle receiving, holdings and transferring native tokens</li>
<li><a href="./fungible-tokens.html">Fungible Token Handling</a>: Convert SPL tokens usage to ERC20 contracts, extensions and interfaces</li>
<li><a href="./non-fungible-tokens.html">Non-Fungible Token Handling</a>: Convert Metaplex NFT metadata to the ERC721 standard</li>
<li><a href="./errors-events.html">Errors and Events</a>: Map program errors to EVM reverts and events</li>
</ol>
<p>Each chapter includes working examples that you can run, test, and build on.</p>
<p><em>This handbook assumes familiarity with Rust and basic blockchain concepts. If you are new to Solana or Arbitrum, review their respective documentation first.</em></p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next steps</a></h2>
<p>With your environment set up and understanding of the handbook structure, you can begin the migration process. The next chapter covers <a href="./program-structure.html">Program Structure Migration</a>, where your Solana program's entry points and instruction handling transform into Stylus contract methods.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-structure-and-instructions"><a class="header" href="#program-structure-and-instructions">Program structure and instructions</a></h1>
<p>This chapter explains how to translate Solana's instruction-dispatch model to Stylus contracts. The transformation involves converting instruction handlers into direct methods, mapping parameter and return types to ABI-encodable forms.</p>
<h2 id="solana-program-model"><a class="header" href="#solana-program-model">Solana program model</a></h2>
<h3 id="native"><a class="header" href="#native">Native</a></h3>
<p>When not using a framework, Solana programs require manual instruction deserialization, account validation and instruction handler routing.</p>
<pre><code class="language-rust">#[derive(BorshSerialize, BorshDeserialize)]
pub struct CounterState {
    pub value: u64,
    pub authority: Pubkey,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum Instruction {
    Initialize { value: u64 },
    Increment,
    SetValue { new_value: u64 },
}

pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    if !check_id(program_id) {
        return Err(ProgramError::IncorrectProgramId);
    }

    let Ok(ix) = Instruction::try_from_slice(instruction_data) else {
        return Err(ProgramError::InvalidInstructionData);
    };

    match ix {
        Instruction::Initialize { value } =&gt; process_initialize(accounts, value),
        Instruction::Increment =&gt; process_increment(accounts),
        Instruction::SetValue { new_value } =&gt; process_set_value(accounts, new_value),
    }
}

fn process_initialize(accounts: &amp;[AccountInfo], initial_value: u64) -&gt; ProgramResult {
    let [counter_state_pda, authority, system_program] = accounts else {
        return Err(ProgramError::InvalidAccountData);
    };

    // Validate accounts, create PDA account &amp; write initial state...

    Ok(())
}

fn process_increment(accounts: &amp;[AccountInfo]) -&gt; ProgramResult {
    let [counter_state_pda] = accounts else {
        return Err(ProgramError::InvalidAccountData);
    };

    // Validate accounts &amp; write incremented value...

    Ok(())
}

fn process_set_value(accounts: &amp;[AccountInfo], new_value: u64) -&gt; ProgramResult {
    let [counter_state_pda, authority] = accounts else {
        return Err(ProgramError::InvalidAccountData);
    };

    // Validate accounts &amp; write new value...

    Ok(())
}</code></pre>
<h3 id="anchor"><a class="header" href="#anchor">Anchor</a></h3>
<p>The Anchor framework abstracts the boilerplate for deserializing instruction data and function routing behind a combination of derive and procedural macros.</p>
<p>Some business logic, such as access control, developers can encode declaratively using attributes within the <code>#[derive(Accounts)]</code> macro.</p>
<pre><code class="language-rust">use anchor_lang::prelude::*;

#[program]
pub mod counter {
    use super::*;
    
    pub fn initialize(ctx: Context&lt;Initialize&gt;, value: u64) -&gt; Result&lt;()&gt; {
        let counter = &amp;mut ctx.accounts.counter;
        counter.value = value;
        counter.authority = ctx.accounts.authority.key();
        Ok(())
    }
    
    pub fn increment(ctx: Context&lt;Increment&gt;) -&gt; Result&lt;()&gt; {
        let counter = &amp;mut ctx.accounts.counter;
        counter.value += 1;
        Ok(())
    }
    
    pub fn set_value(ctx: Context&lt;SetValue&gt;, new_value: u64) -&gt; Result&lt;()&gt; {
        let counter = &amp;mut ctx.accounts.counter;
        counter.value = new_value;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize&lt;'info&gt; {
    #[account(init_if_needed, payer = authority, space = 8 + 8 + 32)]
    pub counter: Account&lt;'info, Counter&gt;,
    #[account(mut)]
    pub authority: Signer&lt;'info&gt;,
    pub system_program: Program&lt;'info, System&gt;,
}

#[derive(Accounts)]
pub struct Increment&lt;'info&gt; {
    #[account(mut)]
    pub counter: Account&lt;'info, Counter&gt;,
}

#[derive(Accounts)]
pub struct SetValue&lt;'info&gt; {
    // Adds the constraint that the `authority` field in the `Counter` account
    // must match the `authority` key within this struct.
    #[account(mut, has_one = authority)]
    pub counter: Account&lt;'info, Counter&gt;,
    pub authority: Signer&lt;'info&gt;,
}

#[account]
pub struct Counter {
    pub value: u64,
    pub authority: Pubkey,
}</code></pre>
<h2 id="stylus-contract-model"><a class="header" href="#stylus-contract-model">Stylus contract model</a></h2>
<p>Stylus uses macros to abstract the boilerplate of decoding calldata and handler function selection.</p>
<p>Unlike Solana, state storage couples to business logic and the contract manages it solely. Functions that change the contract state must take <code>&amp;mut self</code>. Developers conventionally add read-only <code>view</code> functions to access contract state that clients may require. These cost no gas for external callers. Any function that takes <code>&amp;self</code> in a development block tagged with <code>#[public]</code> appears as an externally viewable <code>view</code> function.</p>
<p>The developer can create contracts with some initial state by using the <code>#[constructor]</code> attribute macro to mark the initialization function. This function runs automatically as part of the contract creation flow.</p>
<pre><code class="language-rust">sol! {
    #[derive(Debug, PartialEq, Eq)]
    error Unauthorized(address caller);
}

#[derive(SolidityError, Debug, PartialEq, Eq)]
pub enum CounterError {
    Unauthorized(Unauthorized),
}

#[storage]
#[entrypoint]
pub struct Counter {
    value: StorageU256,
    authority: StorageAddress,
}

#[public]
impl Counter {
    #[constructor]
    pub fn constructor(&amp;mut self, initial_value: U256) {
        let authority = self.vm().msg_sender();

        self.value.set(initial_value);
        self.authority.set(authority);
    }

    pub fn increment(&amp;mut self) -&gt; U256 {
        let new_value = self.value.get() + U256::ONE;

        self.value.set(new_value);

        new_value
    }

    pub fn set_value(&amp;mut self, new_value: U256) -&gt; Result&lt;(), CounterError&gt; {
        let caller = self.vm().msg_sender();

        // Only authority can set value
        if caller != self.authority.get() {
            return Err(CounterError::Unauthorized(Unauthorized { caller }));
        }

        self.value.set(new_value);

        Ok(())
    }

    // View functions
    pub fn get_value(&amp;self) -&gt; U256 {
        self.value.get()
    }

    pub fn get_authority(&amp;self) -&gt; Address {
        self.authority.get()
    }
}</code></pre>
<h2 id="key-transformation-entry-points"><a class="header" href="#key-transformation-entry-points">Key transformation: Entry points</a></h2>
<h3 id="coming-from-native-solana"><a class="header" href="#coming-from-native-solana">Coming from native Solana</a></h3>
<p>A 1-to-1 mapping exists between instruction <code>enum</code> variants and Stylus' <code>#[public]</code> functions that can change state (that take <code>&amp;mut self</code>).</p>
<p>Any fields associated with the instruction <code>enum</code> variants convert to ABI-encodable function parameters.</p>
<h3 id="coming-from-anchor"><a class="header" href="#coming-from-anchor">Coming from Anchor</a></h3>
<p>Each <code>#[program]</code> function that takes a different <code>Context&lt;T&gt;</code> maps to a <code>#[public] &amp;mut self</code> function in Stylus. Any parameters coming after <code>ctx</code> are also required.</p>
<h3 id="stylus-idioms"><a class="header" href="#stylus-idioms">Stylus idioms</a></h3>
<h4 id="function-return-types"><a class="header" href="#function-return-types">Function return types</a></h4>
<p>In both Native and Anchor-based Solana programs, most instruction handlers return a <code>Result&lt;(), ProgramError&gt;</code>, meaning no return data exists when no errors occur.</p>
<p>Stylus operates within the EVM ecosystem where successful function results commonly continue into further computation. This provides much more flexibility when it comes to return types.</p>
<p>Functions may return nothing at all, an infallible result (that just <code>T</code>) or a <code>Result&lt;T, E&gt;</code> where <code>E</code> supports <code>SolidityError</code> and <code>T</code> supports <a href="https://docs.rs/stylus-sdk/latest/stylus_sdk/abi/trait.AbiType.html"><code>AbiType</code></a>. The programmer decides the best approach.</p>
<p>View or pure computation functions typically return infallible results and functions that change state according to some business logic typically return a <code>Result</code> type.</p>
<p>The <a href="./errors-events.html">Errors and Events</a> section covers error type definition in more detail.</p>
<h4 id="contract-state-initialization"><a class="header" href="#contract-state-initialization">Contract state initialization</a></h4>
<p>In Solana programs, initialization appears as just another instruction or series of instructions, but where care must protect unauthorized use.</p>
<p>Stylus, like Solidity contracts, provides a specialized <code>constructor</code> function that runs during contract creation with parameters provided by the contract deployer. Developers commonly use this pattern to provide initial values such as initial authorized addresses and other contract state as parameters to this function.</p>
<h4 id="parameter-types"><a class="header" href="#parameter-types">Parameter types</a></h4>
<p>The constraint on parameter types in Stylus contracts requires that they support <a href="https://docs.rs/stylus-sdk/latest/stylus_sdk/abi/trait.AbiType.html"><code>AbiType</code></a>. This trait parallels the <code>BorshDeserialize</code> and <code>BorshSerialize</code> traits in Solana programs. All primitive types and tuples of primitive types already support this trait.</p>
<p>The Stylus contract programmer can define more complex types such as <code>enums</code> and <code>structs</code> using the <a href="https://docs.rs/alloy-sol-macro/0.8.20/alloy_sol_macro/macro.sol.html"><code>sol!</code> macro</a>. Those patterns fall outside the scope of this guide.</p>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next steps</a></h2>
<p>Now that you understand program structure transformation, explore:</p>
<ul>
<li><a href="./state-storage.html">State Storage</a> - Converting account-based storage to contract storage</li>
<li><a href="./access-control.html">Access Control</a> - Building ownership and permissions</li>
<li><a href="./external-calls.html">External Calls</a> - Making cross-contract calls</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-storage"><a class="header" href="#state-storage">State storage</a></h1>
<p>One of the most significant differences between Solana and Stylus involves how state storage and access work. This chapter covers the transformation from Solana's account-based storage model to Stylus's contract storage variables, including type mappings, access patterns, and cost considerations.</p>
<h2 id="solana-account-model"><a class="header" href="#solana-account-model">Solana account model</a></h2>
<p>Solana stores each piece of state in a separate, dedicated account with predetermined size allocation. Accounts must maintain a rent-exempt balance proportional to their size to avoid automatic deallocation, though closing accounts refunds the Lamports. Programs can only access the accounts provided in the instruction, which is fully client-controlled. Extreme care must be taken to validate the accounts received when processing the instruction in order to prevent exploits.</p>
<h3 id="native-1"><a class="header" href="#native-1">Native</a></h3>
<p>Solana programs can group related state together to be stored in accounts owned by the program. Native programs are required to explicitly create and initialize those accounts.</p>
<pre><code class="language-rust">#[derive(BorshSerialize, BorshDeserialize, Debug, PartialEq, Eq)]
pub struct Data {
    pub bool: bool,
    pub uint8: u8,
    pub uint16: u16,
    pub uint32: u32,
    pub uint64: u64,
    pub uint128: u128,
    pub int8: i8,
    pub int16: i16,
    pub int32: i32,
    pub int64: i64,
    pub int128: i128,
    pub string: String,
    pub bytes: Vec&lt;u8&gt;,
    pub address: Pubkey,
}

pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    if !check_id(program_id) {
        return Err(ProgramError::IncorrectProgramId);
    }

    if Data::try_from_slice(instruction_data).is_err() {
        return Err(ProgramError::InvalidInstructionData);
    };

    let [payer, data_account, system_program] = accounts else {
        return Err(ProgramError::InvalidAccountData);
    };

    let lamports_required = Rent::get()?.minimum_balance(instruction_data.len());

    invoke(
        &amp;system_instruction::create_account(
            payer.key,
            data_account.key,
            lamports_required,
            instruction_data.len() as u64,
            program_id,
        ),
        &amp;[payer.clone(), data_account.clone(), system_program.clone()],
    )?;

    let mut data_account_buffer = data_account.try_borrow_mut_data()?;

    data_account_buffer.copy_from_slice(instruction_data);

    Ok(())
}</code></pre>
<p>State that is to be maintained against other accounts such as user EOAs or other programs stored in accounts associated with Program Derived Addresses (PDAs). Each PDA is derived from a set of seeds, which can be viewed as a prefixed key and a 'bump' byte. In native Solana programs, the program owning the PDA must be careful to create and verify those accounts against the canonical bump seed, as well as protect against re-initialization attacks.</p>
<pre><code class="language-rust">pub static SEED_SEPARATOR: &amp;[u8] = b"-";
pub static PLAYER_PDA_ACCOUNT_SEED: &amp;[u8] = b"player";

pub const STARTING_LIVES: u8 = 10;

#[derive(BorshSerialize, BorshDeserialize)]
pub struct PlayerAccountState {
    pub lives: u8,
}

pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    if !check_id(program_id) {
        return Err(ProgramError::IncorrectProgramId);
    }

    let Ok(args) = PlayerAccountState::try_from_slice(instruction_data) else {
        return Err(ProgramError::InvalidInstructionData);
    };

    // ensure correct initial player state is provided
    if args.lives != STARTING_LIVES {
        return Err(ProgramError::InvalidInstructionData);
    }

    let [payer, player_pda_account, system_program] = accounts else {
        return Err(ProgramError::InvalidAccountData);
    };

    // ensure PDA has not already been initialized
    if !player_pda_account.data_is_empty()
        || player_pda_account.lamports() &gt; 0
        || *player_pda_account.owner == ID
    {
        return Err(ProgramError::AccountAlreadyInitialized);
    }

    let (player_pda_account_key, bump) = Pubkey::find_program_address(
        &amp;[PLAYER_PDA_ACCOUNT_SEED, SEED_SEPARATOR, payer.key.as_ref()],
        &amp;ID,
    );

    if player_pda_account_key != *player_pda_account.key {
        return Err(ProgramError::InvalidSeeds);
    }

    let lamports_required = Rent::get()?.minimum_balance(instruction_data.len());

    invoke_signed(
        &amp;system_instruction::create_account(
            payer.key,
            player_pda_account.key,
            lamports_required,
            instruction_data.len() as u64,
            program_id,
        ),
        &amp;[
            payer.clone(),
            player_pda_account.clone(),
            system_program.clone(),
        ],
        &amp;[&amp;[
            PLAYER_PDA_ACCOUNT_SEED,
            SEED_SEPARATOR,
            payer.key.as_ref(),
            &amp;[bump],
        ]],
    )?;

    let mut data_account_buffer = player_pda_account.try_borrow_mut_data()?;

    data_account_buffer.copy_from_slice(instruction_data);

    Ok(())
}</code></pre>
<h3 id="anchor-1"><a class="header" href="#anchor-1">Anchor</a></h3>
<p>When defining Solana program instructions using the Anchor framework, program-owned accounts can be created automatically using the <code>#[account(init, ...)]</code> attribute. This also implicitly adds checks for already initialized accounts and always uses the canonical bump seed unless otherwise specified.</p>
<pre><code class="language-rust">#[derive(InitSpace)]
#[account]
pub struct Data {
    pub bool: bool,
    pub uint8: u8,
    pub uint16: u16,
    pub uint32: u32,
    pub uint64: u64,
    pub uint128: u128,
    pub int8: i8,
    pub int16: i16,
    pub int32: i32,
    pub int64: i64,
    pub int128: i128,
    #[max_len(200)]
    pub string: String,
    #[max_len(200)]
    pub bytes: Vec&lt;u8&gt;,
    pub address: Pubkey,
}

#[derive(Accounts)]
#[instruction(data: Data)]
pub struct Initialize&lt;'info&gt; {
    #[account(mut)]
    pub payer: Signer&lt;'info&gt;,
    #[account(
        init,
        payer = payer,
        space = 8 + Data::INIT_SPACE
    )]
    pub data_account: Account&lt;'info, Data&gt;,
    pub system_program: Program&lt;'info, System&gt;,
}

#[program]
pub mod data_storage {
    use super::*;

    pub fn initialize(ctx: Context&lt;Initialize&gt;, data: Data) -&gt; Result&lt;()&gt; {
        *ctx.accounts.data_account = data;
        Ok(())
    }
}</code></pre>
<p>The Anchor framework abstracts the boilerplate required to manually create PDA accounts and automatically checks for initialization as well as correct seeds.</p>
<pre><code class="language-rust">#[derive(InitSpace)]
#[account]
pub struct PlayerAccountState {
    pub lives: u8,
}

#[derive(Accounts)]
#[instruction()]
pub struct CreatePlayerAccount&lt;'info&gt; {
    #[account(mut)]
    pub payer: Signer&lt;'info&gt;,
    #[account(
        init,
        payer = payer,
        space = 8 + PlayerAccountState::INIT_SPACE,
        seeds = [PLAYER_PDA_ACCOUNT_SEED, SEED_SEPARATOR, payer.key().as_ref()],
        bump,
    )]
    pub player_account: Account&lt;'info, PlayerAccountState&gt;,
    pub system_program: Program&lt;'info, System&gt;,
}

#[program]
pub mod data_storage {
    use super::*;

    pub fn create_player_account(ctx: Context&lt;CreatePlayerAccount&gt;) -&gt; Result&lt;()&gt; {
        ctx.accounts.player_account.lives = STARTING_LIVES;
        Ok(())
    }
}</code></pre>
<h2 id="stylus-storage-model"><a class="header" href="#stylus-storage-model">Stylus storage model</a></h2>
<p>Stylus stores all state within the contract's storage slots, allowing dynamic growth as needed within gas limits. Storage operations cost gas that users pay during transaction execution, with the smart contract execution VM automatically handling storage accessibility. State persists without ongoing rent requirements, as users only pay costs when writing data and for transaction calldata.</p>
<p>The <code>#[storage]</code> attribute macro can be used to implement <a href="https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.StorageType.html"><code>StorageType</code></a> for user-defined types, allowing state to be logically grouped together.</p>
<pre><code class="language-rust">#[storage]
pub struct IntegerStore {
    uint8: StorageU8,
    uint16: StorageU16,
    uint32: StorageU32,
    uint64: StorageU64,
    uint128: StorageU128,
    uint256: StorageU256,
    int8: StorageI8,
    int16: StorageI16,
    int32: StorageI32,
    int64: StorageI64,
    int128: StorageI128,
    int256: StorageI256,
}

#[storage]
#[entrypoint]
pub struct DataStorage {
    // Types that implement `StorageType` can be nested
    // in order to namespace and organize related storage items
    integers: IntegerStore,
    bool: StorageBool,
    string: StorageString,
    bytes: StorageBytes,
    fixed_bytes: StorageFixedBytes&lt;4&gt;,
    vec: StorageVec&lt;StorageU64&gt;,
    address: StorageAddress,
}

#[public]
impl DataStorage {
    #[constructor]
    // for example purposes only, avoid using this many parameters to functions
    #[allow(clippy::too_many_arguments)]
    pub fn constructor(
        &amp;mut self,
        bool: bool,
        uint8: U8,
        uint16: U16,
        uint32: U32,
        uint64: U64,
        uint128: U128,
        uint256: U256,
        int8: I8,
        int16: I16,
        int32: I32,
        int64: I64,
        int128: I128,
        int256: I256,
        string: String,
        bytes: Vec&lt;u8&gt;,
        fixed_bytes: FixedBytes&lt;4&gt;,
        vec: Vec&lt;U64&gt;,
        address: Address,
    ) {
        // unless explicitly set, all storage is initialized to the types respective zero-value
        self.bool.set(bool);
        self.integers.uint8.set(uint8);
        self.integers.uint16.set(uint16);
        self.integers.uint32.set(uint32);
        self.integers.uint64.set(uint64);
        self.integers.uint128.set(uint128);
        self.integers.uint256.set(uint256);
        self.integers.int8.set(int8);
        self.integers.int16.set(int16);
        self.integers.int32.set(int32);
        self.integers.int64.set(int64);
        self.integers.int128.set(int128);
        self.integers.int256.set(int256);
        self.string.set_str(string);
        self.bytes.set_bytes(bytes);
        self.fixed_bytes.set(fixed_bytes);

        for x in vec {
            self.vec.push(x);
        }

        self.address.set(address);
    }

    fn get_bool(&amp;self) -&gt; bool { self.bool.get() }
    fn get_uint8(&amp;self) -&gt; U8 { self.integers.uint8.get() }
    fn get_uint16(&amp;self) -&gt; U16 { self.integers.uint16.get() }
    fn get_uint32(&amp;self) -&gt; U32 { self.integers.uint32.get() }
    fn get_uint64(&amp;self) -&gt; U64 { self.integers.uint64.get() }
    fn get_uint128(&amp;self) -&gt; U128 { self.integers.uint128.get() }
    fn get_uint256(&amp;self) -&gt; U256 { self.integers.uint256.get() }
    fn get_int8(&amp;self) -&gt; I8 { self.integers.int8.get() }
    fn get_int16(&amp;self) -&gt; I16 { self.integers.int16.get() }
    fn get_int32(&amp;self) -&gt; I32 { self.integers.int32.get() }
    fn get_int64(&amp;self) -&gt; I64 { self.integers.int64.get() }
    fn get_int128(&amp;self) -&gt; I128 { self.integers.int128.get() }
    fn get_int256(&amp;self) -&gt; I256 { self.integers.int256.get() }
    fn get_string(&amp;self) -&gt; String { self.string.get_string() }
    fn get_bytes(&amp;self) -&gt; Vec&lt;u8&gt; { self.bytes.get_bytes() }
    fn get_fixed_bytes(&amp;self) -&gt; FixedBytes&lt;4&gt; { self.fixed_bytes.get() }
    fn get_address(&amp;self) -&gt; Address { self.address.get() }

    // Option&lt;T&gt; is not available as a return or a public function parameter type
    // as `None` cannot be EVM ABI-encoded, hence the use of (bool, T)
    fn get_vec_item(&amp;self, idx: u32) -&gt; (bool, U64) {
        self.vec.get(idx).map_or((false, U64::ZERO), |x| (true, x))
    }
}</code></pre>
<p>The <code>StorageMap</code> type can be used to store state using keys that are calculated at runtime, for example the <code>Address</code> of the caller. Care needs to be taken as the mapped type's zero value will be returned if an entry does not exist for the provided key. For some data this is fine and expected, such as token balances or allowances.</p>
<pre><code class="language-rust">#[storage]
#[entrypoint]
pub struct Mappings {
    player_lives: StorageMap&lt;Address, StorageU8&gt;,
    player_is_dead: StorageMap&lt;Address, StorageBool&gt;,
}

sol! {
    #[derive(Debug, PartialEq, Eq)]
    error PlayerAlreadyExists(address player);

    #[derive(Debug, PartialEq, Eq)]
    error PlayerNotFound(address player);
}

#[derive(SolidityError, Debug, PartialEq, Eq)]
pub enum ContractError {
    PlayerAlreadyExists(PlayerAlreadyExists),
    PlayerNotFound(PlayerNotFound),
}

impl Mappings {
    fn player_exists(&amp;self, player: Address) -&gt; bool {
        self.player_lives.get(player) &gt; U8::ZERO || self.player_is_dead.get(player)
    }
}

#[public]
impl Mappings {
    pub fn create_player_account(&amp;mut self) -&gt; Result&lt;(), ContractError&gt; {
        let msg_sender = self.vm().msg_sender();

        if self.player_exists(msg_sender) {
            return Err(PlayerAlreadyExists { player: msg_sender }.into());
        }

        self.player_lives
            .insert(self.vm().msg_sender(), U8::from(STARTING_LIVES));

        Ok(())
    }

    pub fn get_is_dead(&amp;self, player: Address) -&gt; Result&lt;bool, ContractError&gt; {
        if !self.player_exists(player) {
            return Err(PlayerNotFound { player }.into());
        }

        Ok(self.player_is_dead.get(player))
    }

    pub fn get_lives(&amp;self, player: Address) -&gt; Result&lt;U8, ContractError&gt; {
        if !self.player_exists(player) {
            return Err(PlayerNotFound { player }.into());
        }

        Ok(self.player_lives.get(player))
    }
}</code></pre>
<h2 id="solana-to-stylus-type-mappings"><a class="header" href="#solana-to-stylus-type-mappings">Solana to Stylus type mappings</a></h2>
<h3 id="primitive-types"><a class="header" href="#primitive-types">Primitive types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Solana Type</th><th>Stylus Storage Type</th><th>Rust Parameter/Return Type</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>u8</code></td><td><code>StorageU8</code></td><td><code>U8</code></td><td>Direct mapping</td></tr>
<tr><td><code>u16</code></td><td><code>StorageU16</code></td><td><code>U16</code></td><td>Direct mapping</td></tr>
<tr><td><code>u32</code></td><td><code>StorageU32</code></td><td><code>U32</code></td><td>Direct mapping</td></tr>
<tr><td><code>u64</code></td><td><code>StorageU64</code> or <code>StorageU256</code></td><td><code>U64</code> or <code>U256</code></td><td>Use U256 where ERC standards expect it</td></tr>
<tr><td><code>u128</code></td><td><code>StorageU128</code> or <code>StorageU256</code></td><td><code>U128</code> or <code>U256</code></td><td>Prefer U256 for interoperability</td></tr>
<tr><td><code>bool</code></td><td><code>StorageBool</code></td><td><code>bool</code></td><td>Direct mapping</td></tr>
<tr><td><code>Pubkey</code></td><td><code>StorageAddress</code></td><td><code>Address</code></td><td>Use <code>Address</code> for EOAs and other contracts</td></tr>
<tr><td><code>String</code></td><td><code>StorageString</code></td><td><code>String</code></td><td>Direct mapping</td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>StorageBytes</code></td><td><code>Vec&lt;u8&gt;</code> or <code>Bytes</code></td><td>Direct mapping</td></tr>
<tr><td><code>[u8; N]</code></td><td><code>StorageFixedBytes&lt;N&gt;</code></td><td><code>[u8; N]</code> or <code>FixedBytes&lt;N&gt;</code></td><td>Direct mapping</td></tr>
</tbody></table>
</div>
<h3 id="more-complex-schemas"><a class="header" href="#more-complex-schemas">More complex schemas</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Solana Pattern</th><th>Stylus Storage Pattern</th></tr></thead><tbody>
<tr><td>Several PDAs with fixed seeds</td><td>Multiple structs tagged with <code>#[storage]</code> nested under the struct marked <code>#[entrypoint]</code></td></tr>
<tr><td>PDAs with dynamic seeds, like a user <code>Pubkey</code></td><td>Use <code>StorageMap&lt;K, V&gt;</code> where <code>K</code> consists of the dynamic seed component and <code>V</code> implements <code>StorageType</code></td></tr>
</tbody></table>
</div>
<h3 id="nested-mappings"><a class="header" href="#nested-mappings">Nested mappings</a></h3>
<p>In cases where there are multiple dynamic components of a key, a nested <code>StorageMap</code> can be used.</p>
<pre><code class="language-rust">use stylus_sdk::storage::{StorageMap, StorageU256, StorageBool};

#[storage]
pub struct Transaction {
    amount: StorageU256,
    timestamp: StorageU256,
    completed: StorageBool,
}

#[storage]
#[entrypoint]
pub struct TokenContract {
    allowances: StorageMap&lt;Address, StorageMap&lt;Address, StorageU256&gt;&gt;,
    user_transactions: StorageMap&lt;Address, StorageMap&lt;U256, Transaction&gt;&gt;,
}

#[public]
impl TokenContract {
    pub fn approve(&amp;mut self, spender: Address, amount: U256) {
        self.allowances
            .setter(self.vm().msg_sender())
            .insert(spender, amount);
    }

    pub fn record_transaction(&amp;mut self, tx_id: U256, amount: U256) {
        let block_time = self.vm().block_timestamp();

        // a nested `setter` cannot be called in a single expression
        let mut txs = self.user_transactions.setter(self.vm().msg_sender());
        let mut tx = txs.setter(tx_id);

        tx.amount.set(amount);
        tx.timestamp.set(U256::from(block_time));
        tx.completed.set(true);
    }

    pub fn allowance(&amp;self, owner: Address, spender: Address) -&gt; U256 {
        self.allowances.getter(owner).get(spender)
    }

    pub fn transaction(&amp;self, address: Address, tx_id: U256) -&gt; (U256, U256, bool) {
        let txs = self.user_transactions.getter(address);
        let tx = txs.get(tx_id);

        (tx.amount.get(), tx.timestamp.get(), tx.completed.get())
    }
}</code></pre>
<h2 id="cost-considerations"><a class="header" href="#cost-considerations">Cost considerations</a></h2>
<h3 id="solana-costs"><a class="header" href="#solana-costs">Solana costs</a></h3>
<ul>
<li><strong>Account Creation</strong>: Rent-exempt balance amount (approximately 0.002 SOL per account)</li>
<li><strong>Storage Rent</strong>: Ongoing cost for keeping accounts alive</li>
<li><strong>No Cost for Reads</strong>: Reading account data requires no fee</li>
</ul>
<h3 id="stylus-costs"><a class="header" href="#stylus-costs">Stylus costs</a></h3>
<ul>
<li><strong>Storage Writes</strong>: Gas cost for storing data (approximately 20,000 gas per 32-byte slot)</li>
<li><strong>Storage Reads</strong>: Much cheaper than writes (approximately 200 gas per read)</li>
<li><strong>One-time Cost</strong>: Pay when writing, no ongoing costs</li>
</ul>
<h3 id="optimization-strategies"><a class="header" href="#optimization-strategies">Optimization strategies</a></h3>
<p><strong>Pack Related Data:</strong></p>
<pre><code class="language-rust">// Instead of separate mappings
#[storage]
pub struct Inefficient {
    usernames: StorageMap&lt;Address, StorageString&gt;,
    emails: StorageMap&lt;Address, StorageString&gt;,
    created_at: StorageMap&lt;Address, StorageU256&gt;,
}

// Use a single struct
#[storage]
pub struct Efficient {
    profiles: StorageMap&lt;Address, UserProfile&gt;,
}

#[storage]
pub struct UserProfile {
    username: StorageString,
    email: StorageString,
    created_at: StorageU256,
}</code></pre>
<p><strong>Use Appropriate Types:</strong></p>
<pre><code class="language-rust">#[storage]
pub struct OptimizedStorage {
    // Don't waste space with oversized types
    small_counter: StorageU8,    // for values 0-255
    timestamp: StorageU32,       // sufficient for timestamps
    large_value: StorageU256,    // when needed
    
    // Pack booleans together
    flag1: StorageBool,
    flag2: StorageBool,
    flag3: StorageBool,
    // These will be packed into a single storage slot
}</code></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next steps</a></h2>
<p>With storage patterns understood, the next chapter covers <a href="./access-control.html">Access Control</a> - transforming Solana's signer checks and PDA patterns to Stylus access control mechanisms.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-control"><a class="header" href="#access-control">Access control</a></h1>
<p>This chapter demonstrates how to translate Solana's signer checks and PDA patterns to Stylus. Learn how to verify callers with <a href="https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/trait.MessageAccess.html#tymethod.msg_sender"><code>MessageAccess::msg_sender</code></a>, replace PDAs with contract-controlled state and authorization logic.</p>
<h2 id="solana-authentication-model"><a class="header" href="#solana-authentication-model">Solana authentication model</a></h2>
<p>Solana's stateless program model requires verifying account relationships and signatures to enforce access control. The first step verifies which accounts have signed the instruction. Next, the program checks PDAs: both those derived from access-control configuration and those tied to the state requiring authenticated, mutable access. It then validates that the provided accounts match their expected seeds and the correct program owns them. Only after these checks can the program compare the signer keys with the authorized keys stored in the verified access-control configuration. This model often leads Solana programs to construct hierarchies of PDAs to guarantee that access-control logic applies consistently across all dependent state.</p>
<h3 id="native-2"><a class="header" href="#native-2">Native</a></h3>
<pre><code class="language-rust">#[derive(BorshSerialize, BorshDeserialize, BorshSchema)]
pub struct Config {
    pub authority: Pubkey,
    pub publisher: Pubkey,
}

#[derive(BorshSerialize, BorshDeserialize, BorshSchema)]
pub struct Price {
    pub base: u64,
    pub quote: u64,
    pub timestamp: i64,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum Instruction {
    InitializeConfig { publisher: Pubkey },
    UpdateConfig { publisher: Pubkey },
    PublishPrice { base: u64, quote: u64 },
}

pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    if !check_id(program_id) {
        return Err(ProgramError::IncorrectProgramId);
    }

    let instruction = Instruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    match instruction {
        Instruction::InitializeConfig { publisher } =&gt; {
            process_initialize_config(program_id, accounts, publisher)
        }
        Instruction::UpdateConfig { publisher } =&gt; {
            process_update_config(program_id, accounts, publisher)
        }
        Instruction::PublishPrice { base, quote } =&gt; {
            process_publish_price(program_id, accounts, base, quote)
        }
    }
}

fn process_initialize_config(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    publisher: Pubkey,
) -&gt; ProgramResult {
    let [config_account, authority_account, system_program] = accounts else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !authority_account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    let (config_pda_key, config_bump) =
        Pubkey::find_program_address(&amp;[CONFIG_PDA_SEED], program_id);

    if config_pda_key != *config_account.key {
        return Err(ProgramError::InvalidSeeds);
    }

    if !config_account.data_is_empty()
        || config_account.lamports() &gt; 0
        || *config_account.owner == *program_id
    {
        return Err(ProgramError::AccountAlreadyInitialized);
    }

    let space_required = borsh::max_serialized_size::&lt;Config&gt;().expect("infallible");
    let lamports_required = Rent::get()?.minimum_balance(space_required);

    invoke_signed(
        &amp;system_instruction::create_account(
            authority_account.key,
            config_account.key,
            lamports_required,
            space_required as u64,
            program_id,
        ),
        &amp;[
            authority_account.clone(),
            config_account.clone(),
            system_program.clone(),
        ],
        &amp;[&amp;[CONFIG_PDA_SEED, &amp;[config_bump]]],
    )?;

    let mut account_data = config_account.try_borrow_mut_data()?;

    Config {
        authority: *authority_account.key,
        publisher,
    }
    .serialize(&amp;mut account_data.as_mut())?;

    Ok(())
}

fn process_update_config(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    publisher: Pubkey,
) -&gt; ProgramResult {
    let [config_account, authority_account] = accounts else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !authority_account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    let (config_pda_key, _) = Pubkey::find_program_address(&amp;[CONFIG_PDA_SEED], program_id);
    if config_pda_key != *config_account.key {
        return Err(ProgramError::InvalidSeeds);
    }

    if *config_account.owner != *program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    let mut config_data = Config::try_from_slice(&amp;config_account.data.borrow())
        .map_err(|_| ProgramError::InvalidAccountData)?;

    if config_data.authority != *authority_account.key {
        return Err(ProgramError::MissingRequiredSignature);
    }

    config_data.publisher = publisher;

    let mut account_data = config_account.try_borrow_mut_data()?;
    config_data.serialize(&amp;mut account_data.as_mut())?;

    Ok(())
}

fn process_publish_price(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    base: u64,
    quote: u64,
) -&gt; ProgramResult {
    let [config_account, last_price_account, publisher_account, system_program] = accounts else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !publisher_account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    let (config_pda_key, _) = Pubkey::find_program_address(&amp;[CONFIG_PDA_SEED], program_id);

    if config_pda_key != *config_account.key {
        return Err(ProgramError::InvalidSeeds);
    }

    if *config_account.owner != *program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    let config_data = Config::try_from_slice(&amp;config_account.data.borrow())
        .map_err(|_| ProgramError::InvalidAccountData)?;

    if config_data.publisher != *publisher_account.key {
        return Err(ProgramError::MissingRequiredSignature);
    }

    let (last_price_pda_key, last_price_bump) = Pubkey::find_program_address(
        &amp;[LAST_PRICE_PDA_SEED, config_account.key.as_ref()],
        program_id,
    );

    if last_price_pda_key != *last_price_account.key {
        return Err(ProgramError::InvalidSeeds);
    }

    let needs_init = last_price_account.data_is_empty()
        || last_price_account.lamports() == 0
        || *last_price_account.owner != *program_id;

    if needs_init {
        let space_required = borsh::max_serialized_size::&lt;Price&gt;().expect("infallible");
        let lamports_required = Rent::get()?.minimum_balance(space_required);

        invoke_signed(
            &amp;system_instruction::create_account(
                publisher_account.key,
                last_price_account.key,
                lamports_required,
                space_required as u64,
                program_id,
            ),
            &amp;[
                publisher_account.clone(),
                last_price_account.clone(),
                system_program.clone(),
            ],
            &amp;[&amp;[
                LAST_PRICE_PDA_SEED,
                config_account.key.as_ref(),
                &amp;[last_price_bump],
            ]],
        )?;
    }

    // Update price data
    let price_data = Price {
        base,
        quote,
        timestamp: Clock::get()?.unix_timestamp,
    };

    let mut account_data = last_price_account.try_borrow_mut_data()?;
    price_data.serialize(&amp;mut account_data.as_mut())?;

    Ok(())
}</code></pre>
<h3 id="anchor-2"><a class="header" href="#anchor-2">Anchor</a></h3>
<pre><code class="language-rust">#[program]
pub mod access_control {
    use super::*;

    pub fn initialize_config(ctx: Context&lt;InitializeConfig&gt;, publisher: Pubkey) -&gt; Result&lt;()&gt; {
        let config = &amp;mut ctx.accounts.config;
        config.authority = ctx.accounts.authority.key();
        config.publisher = publisher;
        Ok(())
    }

    pub fn update_config(ctx: Context&lt;UpdateConfig&gt;, publisher: Pubkey) -&gt; Result&lt;()&gt; {
        let config = &amp;mut ctx.accounts.config;
        config.publisher = publisher;
        Ok(())
    }

    pub fn publish_price(ctx: Context&lt;PublishPrice&gt;, base: u64, quote: u64) -&gt; Result&lt;()&gt; {
        let last_price = &amp;mut ctx.accounts.last_price;
        last_price.base = base;
        last_price.quote = quote;
        last_price.timestamp = Clock::get()?.unix_timestamp;
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(publisher: Pubkey)]
pub struct InitializeConfig&lt;'info&gt; {
    #[account(
        init,
        payer = authority,
        space = 8 + Config::INIT_SPACE,
        seeds = [CONFIG_PDA_SEED],
        bump
    )]
    pub config: Account&lt;'info, Config&gt;,
    #[account(mut)]
    pub authority: Signer&lt;'info&gt;,
    pub system_program: Program&lt;'info, System&gt;,
}

#[derive(Accounts)]
#[instruction(publisher: Pubkey)]
pub struct UpdateConfig&lt;'info&gt; {
    #[account(mut, has_one = authority, seeds = [CONFIG_PDA_SEED], bump)]
    pub config: Account&lt;'info, Config&gt;,
    pub authority: Signer&lt;'info&gt;,
}

#[derive(Accounts)]
#[instruction(base: u64, quote: u64)]
pub struct PublishPrice&lt;'info&gt; {
    #[account(has_one = publisher, seeds = [CONFIG_PDA_SEED], bump)]
    pub config: Account&lt;'info, Config&gt;,
    #[account(
        init_if_needed,
        payer = publisher,
        space = 8 + Price::INIT_SPACE,
        seeds = [LAST_PRICE_PDA_SEED, config.key().as_ref()],
        bump
    )]
    pub last_price: Account&lt;'info, Price&gt;,
    #[account(mut)]
    pub publisher: Signer&lt;'info&gt;,
    pub system_program: Program&lt;'info, System&gt;,
}

#[derive(InitSpace)]
#[account]
pub struct Config {
    pub authority: Pubkey,
    pub publisher: Pubkey,
}

#[derive(InitSpace)]
#[account]
pub struct Price {
    pub base: u64,
    pub quote: u64,
    pub timestamp: i64,
}</code></pre>
<h2 id="stylus-authentication-model"><a class="header" href="#stylus-authentication-model">Stylus authentication model</a></h2>
<p>Stylus contracts handle access control by checking the caller address relative to those stored in the contract's state. The contract obtains the caller address using the <a href="https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/trait.MessageAccess.html#tymethod.msg_sender"><code>MessageAccess::msg_sender</code></a> trait method.</p>
<pre><code class="language-rust">#[storage]
pub struct Config {
    authority: StorageAddress,
    publisher: StorageAddress,
}

#[storage]
pub struct Price {
    base: StorageU256,
    quote: StorageU256,
    timestamp: StorageU64,
}

#[storage]
#[entrypoint]
pub struct AccessControl {
    config: Config,
    last_price: Price,
}

sol! {
    #[derive(Debug, PartialEq, Eq)]
    error InvalidAddress(address address);
    #[derive(Debug, PartialEq, Eq)]
    error Unauthorized();
}

#[derive(SolidityError, Debug, PartialEq, Eq)]
pub enum AccessControlError {
    InvalidAddress(InvalidAddress),
    Unauthorized(Unauthorized),
}

#[public]
impl AccessControl {
    #[constructor]
    pub fn constructor(&amp;mut self, authority: Address, publisher: Address) {
        assert_ne!(
            authority,
            Address::ZERO,
            "authority cannot be a zero-address"
        );
        assert_ne!(
            publisher,
            Address::ZERO,
            "publisher cannot be a zero-address"
        );

        self.config.authority.set(authority);
        self.config.publisher.set(publisher);
    }

    pub fn update_config(&amp;mut self, publisher: Address) -&gt; Result&lt;(), AccessControlError&gt; {
        let sender = self.vm().msg_sender();

        if sender != self.config.authority.get() {
            return Err(AccessControlError::Unauthorized(Unauthorized {}));
        }

        if publisher == Address::ZERO {
            return Err(AccessControlError::InvalidAddress(InvalidAddress {
                address: publisher,
            }));
        }

        self.config.publisher.set(publisher);

        Ok(())
    }

    pub fn publish_price(&amp;mut self, base: U256, quote: U256) -&gt; Result&lt;(), AccessControlError&gt; {
        let sender = self.vm().msg_sender();

        if sender != self.config.publisher.get() {
            return Err(AccessControlError::Unauthorized(Unauthorized {}));
        }

        let timestamp = self.vm().block_timestamp();

        self.last_price.base.set(base);
        self.last_price.quote.set(quote);
        self.last_price.timestamp.set(U64::from(timestamp));

        Ok(())
    }

    pub fn get_authority(&amp;self) -&gt; Address {
        self.config.authority.get()
    }

    pub fn get_publisher(&amp;self) -&gt; Address {
        self.config.publisher.get()
    }

    pub fn get_last_price(&amp;self) -&gt; (U256, U256, U64) {
        (
            self.last_price.base.get(),
            self.last_price.quote.get(),
            self.last_price.timestamp.get(),
        )
    }
}</code></pre>
<h2 id="standardized-access-control-patterns"><a class="header" href="#standardized-access-control-patterns">Standardized access control patterns</a></h2>
<p>The most common access control pattern involves a contract having an admin or an <a href="https://docs.openzeppelin.com/contracts/5.x/access-control#ownership-and-ownable">owner</a>. The account with the owner role can perform actions such as pausing and unpausing the contract or update the configuration.</p>
<p>OpenZeppelin develops many well-used and audited re-usable components for EVM-based contracts. They have ported many of those components from Solidity to Rust using Stylus' inheritance and state composition features.</p>
<p>For example, the Two-Step Ownership component implements ownership tracking and enables safe ownership transitions.</p>
<pre><code class="language-rust">sol! {
    #[derive(Debug)]
    error ContractAlreadyPaused();
    #[derive(Debug)]
    error ContractAlreadyUnpaused();
}

#[derive(SolidityError, Debug)]
// In order to generate an ABI for the contract you need to manually wire
// up OpenZeppelin's error types defined with `sol!` rather than the their
// `ownable::Error` type which does not implement `SolError`
pub enum ContractError {
    InvalidOwner(ownable::OwnableInvalidOwner),
    Unauthorized(ownable::OwnableUnauthorizedAccount),
    AlreadyPaused(ContractAlreadyPaused),
    AlreadyUnpaused(ContractAlreadyUnpaused),
}

impl From&lt;ownable::Error&gt; for ContractError {
    fn from(value: ownable::Error) -&gt; Self {
        match value {
            ownable::Error::UnauthorizedAccount(e) =&gt; Self::Unauthorized(e),
            ownable::Error::InvalidOwner(e) =&gt; Self::InvalidOwner(e),
        }
    }
}

#[storage]
#[entrypoint]
pub struct OwnableContract {
    // Nest the OpenZeppelin implementation within the contract
    ownable: Ownable2Step,
    is_paused: StorageBool,
}

#[public]
#[implements(IOwnable2Step&lt;Error = ownable::Error&gt;)]
impl OwnableContract {
    #[constructor]
    pub fn constructor(&amp;mut self, owner: Address) -&gt; Result&lt;(), ContractError&gt; {
        assert_ne!(owner, Address::ZERO, "owner cannot be a zero-address");

        self.ownable.constructor(owner)?;

        self.is_paused.set(true);

        Ok(())
    }

    pub fn pause_contract(&amp;mut self) -&gt; Result&lt;(), ContractError&gt; {
        // You can then use convenience methods on the nested implementation
        self.ownable.only_owner()?;

        if self.is_paused() {
            return Err(ContractAlreadyPaused {}.into());
        }

        self.is_paused.set(true);

        Ok(())
    }

    pub fn unpause_contract(&amp;mut self) -&gt; Result&lt;(), ContractError&gt; {
        self.ownable.only_owner()?;

        if !self.is_paused() {
            return Err(ContractAlreadyUnpaused {}.into());
        }

        self.is_paused.set(false);

        Ok(())
    }

    pub fn is_paused(&amp;self) -&gt; bool {
        self.is_paused.get()
    }
}

#[public]
// Wire everything up by delegating interface trait methods to the nested implementation.
// You could modify the standard behavior here if you wished.
impl IOwnable2Step for OwnableContract {
    type Error = ownable::Error;

    fn owner(&amp;self) -&gt; Address {
        self.ownable.owner()
    }

    fn pending_owner(&amp;self) -&gt; Address {
        self.ownable.pending_owner()
    }

    fn transfer_ownership(&amp;mut self, new_owner: Address) -&gt; Result&lt;(), Self::Error&gt; {
        self.ownable.transfer_ownership(new_owner)
    }

    fn accept_ownership(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {
        self.ownable.accept_ownership()
    }

    fn renounce_ownership(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {
        self.ownable.renounce_ownership()
    }
}</code></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next steps</a></h2>
<p>With access control patterns established, the next chapter covers <a href="./external-calls.html">External Calls</a> - converting Solana's Cross-Program Invocations (CPIs) to Stylus contract calls.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-calls"><a class="header" href="#external-calls">External Calls</a></h1>
<p>This chapter demonstrates how to translate Solana CPIs into Stylus external calls.</p>
<h2 id="solana"><a class="header" href="#solana">Solana</a></h2>
<p>Solana’s Cross-Program Invocation (CPI) model relies on instruction-based communication. Programs build instructions with the target program ID, required accounts, and instruction data. Unlike systems that allow direct state queries, Solana programs must receive all state through accounts passed in the transaction. CPIs are therefore used when a program needs to modify state owned by another program, with the caller explicitly providing all accounts the callee requires.</p>
<p>When a program controls a PDA that must sign for another program’s operation, it uses <code>invoke_signed</code> with the PDA’s seeds. The runtime verifies the seeds and grants signing authority.</p>
<h3 id="native-3"><a class="header" href="#native-3">Native</a></h3>
<pre><code class="language-rust">#[derive(BorshSerialize, BorshDeserialize)]
pub struct LastResultAccount {
    pub last_result: u128,
}

pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    if !check_id(program_id) {
        return Err(ProgramError::IncorrectProgramId);
    }

    if AdderArgs::try_from_slice(instruction_data).is_err() {
        return Err(ProgramError::InvalidInstructionData);
    };

    let [payer, last_result_account, system_program, adder_program] = accounts else {
        return Err(ProgramError::InvalidAccountData);
    };

    if *adder_program.key != ADDER_PROGRAM_ID {
        return Err(ProgramError::InvalidAccountData);
    }

    // Find the expected PDA and bump
    let (expected_pda, bump) =
        Pubkey::find_program_address(&amp;[LAST_RESULT_ACCOUNT_SEED], program_id);

    // Verify the provided account matches the expected PDA
    if last_result_account.key != &amp;expected_pda {
        return Err(ProgramError::InvalidSeeds);
    }

    invoke(
        &amp;solana_program::instruction::Instruction {
            program_id: cpi_to_external_call_solana_adder::ID,
            accounts: vec![],
            data: instruction_data.to_owned(),
        },
        &amp;[adder_program.clone()],
    )?;

    let (invoked_program, data) = get_return_data().expect("return data is some after invoke");

    assert_eq!(
        invoked_program, ADDER_PROGRAM_ID,
        "expected return data from {ADDER_PROGRAM_ID}, received from {invoked_program}"
    );

    let Response { result } = Response::try_from_slice(&amp;data)?;

    let last_result_account_data = borsh::to_vec(&amp;LastResultAccount {
        last_result: result,
    })?;

    // Check if LastResult PDA Account needs to be created
    if last_result_account.owner != program_id {
        let rent = Rent::get()?;
        let required_lamports = rent.minimum_balance(last_result_account_data.len());

        invoke_signed(
            &amp;system_instruction::create_account(
                payer.key,
                last_result_account.key,
                required_lamports,
                last_result_account_data.len() as u64,
                program_id,
            ),
            &amp;[
                payer.clone(),
                last_result_account.clone(),
                system_program.clone(),
            ],
            &amp;[&amp;[LAST_RESULT_ACCOUNT_SEED, &amp;[bump]]],
        )?;
    }

    last_result_account
        .try_borrow_mut_data()?
        .copy_from_slice(&amp;last_result_account_data);

    Ok(())
}</code></pre>
<h3 id="anchor-3"><a class="header" href="#anchor-3">Anchor</a></h3>
<pre><code class="language-rust">#[derive(AnchorDeserialize, AnchorSerialize)]
pub struct Args {
    pub a: u64,
    pub b: u64,
}

#[derive(InitSpace)]
#[account]
pub struct LastResultAccount {
    pub last_result: u128,
}

#[derive(Accounts)]
#[instruction(data: Args)]
pub struct Add&lt;'info&gt; {
    #[account(mut)]
    pub payer: Signer&lt;'info&gt;,
    #[account(
        init_if_needed,
        payer = payer,
        space = 8 + LastResultAccount::INIT_SPACE,
        seeds = [LAST_RESULT_ACCOUNT_SEED],
        bump,
    )]
    pub last_result: Account&lt;'info, LastResultAccount&gt;,
    pub system_program: Program&lt;'info, System&gt;,
    pub adder_program: UncheckedAccount&lt;'info&gt;,
}

#[program]
pub mod cpi {
    use super::*;

    pub fn add(ctx: Context&lt;Add&gt;, args: Args) -&gt; Result&lt;()&gt; {
        if *ctx.accounts.adder_program.key != ADDER_PROGRAM_ID {
            return Err(ProgramError::InvalidAccountData.into());
        }

        let adder_instruction_data = ::borsh::to_vec(&amp;AdderArgs {
            a: args.a,
            b: args.b,
        })
        .expect("infallible serialization");

        invoke(
            &amp;Instruction {
                program_id: ADDER_PROGRAM_ID,
                accounts: vec![],
                data: adder_instruction_data,
            },
            &amp;[ctx.accounts.adder_program.to_account_info()],
        )?;

        let (invoked_program, data) = get_return_data().expect("return data is some after invoke");

        assert_eq!(
            invoked_program, ADDER_PROGRAM_ID,
            "expected return data from {ADDER_PROGRAM_ID}, received from {invoked_program}"
        );

        let Response { result } = Response::try_from_slice(&amp;data)?;

        ctx.accounts.last_result.last_result = result;

        Ok(())
    }
}</code></pre>
<h2 id="stylus"><a class="header" href="#stylus">Stylus</a></h2>
<p>Stylus contracts use an EVM ABI encoding model that supports calling both state queries and modification functions. Unlike Solana, where all state must be passed explicitly, Stylus contracts can directly call any other contracts, using static calls to read state or regular calls to modify it.</p>
<p>Call contexts are configured via the Call type, giving fine-grained control over gas limits and value transfers. Stylus provides two abstraction layers: high-level typed interfaces generated by <code>sol_interface!</code>, and low-level <code>call</code>, <code>static_call</code>, and <code>RawCall</code> methods for direct byte manipulation when needed.</p>
<div class="warning">
Stylus contracts revert on reentrant calls by default, blocking an entire class of exploits. You can enable reentrancy with the reentrant feature flag, but this is highly dangerous and should only be done after expert review.
</div>
<pre><code class="language-rust">fn add_calldata(a: u64, b: u64) -&gt; Vec&lt;u8&gt; {
    [
        [110u8, 44u8, 115u8, 45u8].as_slice(), // keccak(b"add(uint64,uint64)")[..4],
        abi::encode_params(&amp;(a, b)).as_slice(),
    ]
    .concat()
}

// function add(uint64 a, uint64 b) external view returns (uint128);
// returns a big-endian u128 (16 bytes) padded to 32 bytes
fn parse_add_returndata(returndata: &amp;[u8]) -&gt; Option&lt;u128&gt; {
    if returndata.len() != 32 {
        return None;
    }

    returndata[16..].try_into().map(u128::from_be_bytes).ok()
}

#[storage]
#[entrypoint]
pub struct ExternalCaller {
    /// A negative value indicates no result has been obtained yet
    last_result: StorageI256,
    adder_address: StorageAddress,
}

#[public]
impl ExternalCaller {
    #[constructor]
    pub fn constructor(&amp;mut self, adder_address: Address) {
        assert_ne!(
            adder_address,
            Address::ZERO,
            "adder_address cannot be a zero-address"
        );
        assert!(
            self.vm().code_size(adder_address) &gt; 0,
            "adder_address must be a contract"
        );

        self.last_result.set(I256::MINUS_ONE);
        self.adder_address.set(adder_address);
    }

    pub fn add(&amp;mut self, a: u64, b: u64) -&gt; u128 {
        // low-level static call used to allow unit testing
        // sol_interface! generated interfaces can only be tested in a WASM runtime
        // see: https://github.com/OffchainLabs/stylus-sdk-rs/issues/301
        let returndata = self
            .vm()
            .static_call(
                &amp;calls::context::Call::new(),
                self.get_adder_address(),
                &amp;add_calldata(a, b),
            )
            .expect("valid contract call");

        let result = parse_add_returndata(&amp;returndata).expect("valid return data");

        self.last_result.set(I256::unchecked_from(result));

        result
    }

    pub fn get_adder_address(&amp;self) -&gt; Address {
        self.adder_address.get()
    }

    pub fn get_last_result(&amp;self) -&gt; I256 {
        self.last_result.get()
    }
}</code></pre>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>With external calls mastered, you're ready to explore:</p>
<ul>
<li><a href="./native-tokens.html">Native Token Handling</a> - Differences in receiving, escrowing and transferring native SOL and ETH</li>
<li><a href="./fungible-tokens.html">Fungible Tokens</a> - Migrating SPL tokens to ERC-20</li>
<li><a href="./non-fungible-tokens.html">Non-Fungible Tokens</a> - Migrating Metaplex NFTs to ERC-721</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-token-handling"><a class="header" href="#native-token-handling">Native Token Handling</a></h1>
<p>This chapter maps handling native SOL to ETH in Stylus: payable functions, internal balance accounting, safe withdrawals, and the key behavioral differences between Lamports and Wei.</p>
<h2 id="solana-1"><a class="header" href="#solana-1">Solana</a></h2>
<p>Solana's native token SOL is handled through the System Program. Programs transfer Lamports via CPIs, check balances through account fields, and receive SOL by accepting transfers to program-owned accounts. Each account maintains a <code>lamports</code> field that tracks its SOL balance, and rent requirements mean accounts must maintain minimum balances. Programs use PDAs to escrow SOL and manage program-owned funds separately from user accounts.</p>
<h4 id="native-4"><a class="header" href="#native-4">Native</a></h4>
<pre><code class="language-rust">#[derive(BorshSerialize, BorshDeserialize)]
pub struct WithdrawAllLamports {}

pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    if !check_id(program_id) {
        return Err(ProgramError::IncorrectProgramId);
    }

    if WithdrawAllLamports::try_from_slice(instruction_data).is_err() {
        return Err(ProgramError::InvalidInstructionData);
    };

    let [payer, deposit_account, system_program] = accounts else {
        return Err(ProgramError::InvalidAccountData);
    };

    if !payer.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    if system_program.key != &amp;solana_program::system_program::ID {
        return Err(ProgramError::IncorrectProgramId);
    }

    if deposit_account.owner != &amp;solana_program::system_program::ID {
        return Err(ProgramError::IllegalOwner);
    }

    // Verify the PDA matches seeds
    let (expected_deposit_pda, bump) = Pubkey::find_program_address(
        &amp;[DEPOSIT_PDA_ACCOUNT_SEED, SEED_SEPARATOR, payer.key.as_ref()],
        program_id,
    );

    if deposit_account.key != &amp;expected_deposit_pda {
        return Err(ProgramError::InvalidSeeds);
    }

    let ix =
        system_instruction::transfer(deposit_account.key, payer.key, deposit_account.lamports());

    let signer_seeds: &amp;[&amp;[&amp;[u8]]] = &amp;[&amp;[
        DEPOSIT_PDA_ACCOUNT_SEED,
        SEED_SEPARATOR,
        payer.key.as_ref(),
        &amp;[bump],
    ]];

    invoke_signed(
        &amp;ix,
        &amp;[
            deposit_account.clone(),
            payer.clone(),
            system_program.clone(),
        ],
        signer_seeds,
    )?;

    Ok(())
}</code></pre>
<h4 id="anchor-4"><a class="header" href="#anchor-4">Anchor</a></h4>
<pre><code class="language-rust">#[program]
pub mod native_token_handling {
    use super::*;

    pub fn withdraw_all_lamports(ctx: Context&lt;WithdrawAllLamports&gt;) -&gt; Result&lt;()&gt; {
        system_program::transfer(
            CpiContext::new(
                ctx.accounts.system_program.to_account_info(),
                system_program::Transfer {
                    from: ctx.accounts.deposit_account.to_account_info(),
                    to: ctx.accounts.payer.to_account_info(),
                },
            )
            .with_signer(&amp;[&amp;[
                DEPOSIT_PDA_ACCOUNT_SEED,
                SEED_SEPARATOR,
                ctx.accounts.payer.key.as_ref(),
                &amp;[ctx.bumps.deposit_account],
            ]]),
            ctx.accounts.deposit_account.lamports(),
        )?;

        Ok(())
    }
}

#[derive(Accounts)]
#[instruction()]
pub struct WithdrawAllLamports&lt;'info&gt; {
    #[account(mut)]
    pub payer: Signer&lt;'info&gt;,
    #[account(
        seeds = [DEPOSIT_PDA_ACCOUNT_SEED, SEED_SEPARATOR, payer.key().as_ref()],
        bump,
    )]
    pub deposit_account: SystemAccount&lt;'info&gt;,
    pub system_program: Program&lt;'info, System&gt;,
}</code></pre>
<h2 id="stylus-1"><a class="header" href="#stylus-1">Stylus</a></h2>
<p>Stylus contracts receive ETH by marking functions as <code>#[payable]</code>, check received amounts via <code>MessageAccess::msg_value</code>, and transfer ETH using <code>ValueTransfer::transfer_eth</code>. Unlike Solana's account model, contracts maintain internal mappings for user balances and implement withdrawal patterns.</p>
<pre><code class="language-rust">#[storage]
#[entrypoint]
pub struct NativeTokenHandling {
    deposits: StorageMap&lt;Address, StorageU256&gt;,
}

sol! {
    #[derive(Debug, PartialEq)]
    error ZeroDeposit();
    #[derive(Debug, PartialEq)]
    error BalanceOverflow(address address, uint existing_balance, uint deposit);
    #[derive(Debug, PartialEq)]
    error DepositNotFound(address address);
    #[derive(Debug, PartialEq)]
    error TransferFailed(address to, uint amount, bytes error);
}

#[derive(SolidityError, Debug, PartialEq)]
pub enum ContractError {
    ZeroDeposit(ZeroDeposit),
    BalanceOverflow(BalanceOverflow),
    DepositNotFound(DepositNotFound),
    TransferFailed(TransferFailed),
}

#[public]
impl NativeTokenHandling {
    #[payable]
    pub fn deposit(&amp;mut self) -&gt; Result&lt;(), ContractError&gt; {
        let sender = self.vm().msg_sender();

        let amount = self.vm().msg_value();

        if amount.is_zero() {
            return Err(ZeroDeposit {}.into());
        }

        let existing_balance = self.balance(sender);

        let new_balance = existing_balance
            .checked_add(amount)
            .ok_or(BalanceOverflow {
                address: sender,
                existing_balance,
                deposit: amount,
            })?;

        self.deposits.insert(sender, new_balance);

        Ok(())
    }

    pub fn withdraw_all(&amp;mut self) -&gt; Result&lt;(), ContractError&gt; {
        let sender = self.vm().msg_sender();

        let balance = self.deposits.take(sender);

        if balance.is_zero() {
            return Err(DepositNotFound { address: sender }.into());
        }

        self.vm()
            .transfer_eth(sender, balance)
            .map_err(Bytes::from)
            .map_err(|error| TransferFailed {
                to: sender,
                amount: balance,
                error,
            })?;

        Ok(())
    }

    pub fn balance(&amp;self, address: Address) -&gt; U256 {
        self.deposits.get(address)
    }
}</code></pre>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<p>With native token handling covered, the next chapter explores <a href="./fungible-tokens.html">Fungible Token Handling</a> - migrating SPL Token operations to ERC-20 patterns in Stylus contracts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fungible-token-handling"><a class="header" href="#fungible-token-handling">Fungible Token Handling</a></h1>
<p>SPL Tokens provide fundamental standardized fungible token functionality for Solana applications. This chapter covers migrating SPL Token operations to ERC-20 patterns in Stylus, including instantiating, minting, transfers, and allowance mechanisms.</p>
<p>To illustrate a range of token operations in a concise example, we will implement a contract that creates a stakeable token with a capped supply.</p>
<h2 id="solana-2"><a class="header" href="#solana-2">Solana</a></h2>
<p>Solana separates token logic from user programs: the SPL Token program owns all mint and token accounts, requiring programs to use CPIs for any token operations. Each token needs a mint account (storing decimals, supply, authorities) and separate token accounts per holder. Programs manage PDAs for both their own state and any token accounts they control, never directly manipulating token balances. The mint authority controls token creation, while freeze authorities handle compliance. Token-2022 adds extensions like transfer fees and metadata while maintaining the same architectural model.</p>
<h4 id="native-5"><a class="header" href="#native-5">Native</a></h4>
<pre><code class="language-rust">#[derive(BorshSerialize, BorshDeserialize)]
pub enum Instruction {
    Initialize,
    Stake { amount: u64 },
    Unstake { amount: u64 },
}

pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    if !check_id(program_id) {
        return Err(ProgramError::IncorrectProgramId);
    }

    let instruction = Instruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    match instruction {
        Instruction::Initialize =&gt; process_initialize(program_id, accounts),
        Instruction::Stake { amount } =&gt; process_stake(program_id, accounts, amount),
        Instruction::Unstake { amount } =&gt; process_unstake(program_id, accounts, amount),
    }
}

fn process_initialize(program_id: &amp;Pubkey, accounts: &amp;[AccountInfo]) -&gt; ProgramResult {
    let [mint_account, mint_supply_to_account, signer_account, token_program, associated_token_program, system_program, rent_sysvar] =
        accounts
    else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !signer_account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    if *token_program.key != spl_token_2022::id()
        || *associated_token_program.key != spl_associated_token_account::id()
        || *system_program.key != system_program::id()
        || *rent_sysvar.key != rent::sysvar::id()
    {
        return Err(ProgramError::IncorrectProgramId);
    }

    let (mint_pda_key, mint_bump) = Pubkey::find_program_address(&amp;[MINT_PDA_SEED], program_id);

    if mint_pda_key != *mint_account.key {
        return Err(ProgramError::InvalidSeeds);
    }

    if !mint_account.data_is_empty()
        || mint_account.lamports() &gt; 0
        || *mint_account.owner == spl_token_2022::id()
    {
        return Err(ProgramError::AccountAlreadyInitialized);
    }

    if !mint_supply_to_account.data_is_empty()
        || mint_supply_to_account.lamports() &gt; 0
        || *mint_supply_to_account.owner == spl_token_2022::id()
    {
        return Err(ProgramError::AccountAlreadyInitialized);
    }

    // Derive the expected associated token account address
    let expected_ata = spl_associated_token_account::get_associated_token_address_with_program_id(
        signer_account.key,
        &amp;mint_pda_key,
        &amp;spl_token_2022::id(),
    );

    if expected_ata != *mint_supply_to_account.key {
        return Err(ProgramError::InvalidAccountData);
    }

    // Create mint account
    let space_required = Mint::get_packed_len();
    let lamports_required = Rent::get()?.minimum_balance(space_required);

    invoke_signed(
        &amp;system_instruction::create_account(
            signer_account.key,
            mint_account.key,
            lamports_required,
            space_required as u64,
            &amp;spl_token_2022::id(),
        ),
        &amp;[
            signer_account.clone(),
            mint_account.clone(),
            system_program.clone(),
        ],
        &amp;[&amp;[MINT_PDA_SEED, &amp;[mint_bump]]],
    )?;

    // Initialize mint
    invoke_signed(
        &amp;token_instruction::initialize_mint(
            &amp;spl_token_2022::id(),
            mint_account.key,
            mint_account.key,
            Some(mint_account.key),
            DECIMALS,
        )?,
        &amp;[mint_account.clone(), rent_sysvar.clone()],
        &amp;[&amp;[MINT_PDA_SEED, &amp;[mint_bump]]],
    )?;

    // Create associated token account
    invoke_signed(
        &amp;associated_token_instruction::create_associated_token_account(
            signer_account.key,
            signer_account.key,
            mint_account.key,
            &amp;spl_token_2022::id(),
        ),
        &amp;[
            signer_account.clone(),
            mint_supply_to_account.clone(),
            signer_account.clone(),
            mint_account.clone(),
            system_program.clone(),
            token_program.clone(),
            associated_token_program.clone(),
        ],
        &amp;[&amp;[MINT_PDA_SEED, &amp;[mint_bump]]],
    )?;

    // Mint total supply to the associated token account
    invoke_signed(
        &amp;token_instruction::mint_to(
            &amp;spl_token_2022::id(),
            mint_account.key,
            mint_supply_to_account.key,
            mint_account.key,
            &amp;[],
            TOTAL_SUPPLY,
        )?,
        &amp;[
            mint_account.clone(),
            mint_supply_to_account.clone(),
            mint_account.clone(),
        ],
        &amp;[&amp;[MINT_PDA_SEED, &amp;[mint_bump]]],
    )?;

    Ok(())
}

fn process_stake(program_id: &amp;Pubkey, accounts: &amp;[AccountInfo], amount: u64) -&gt; ProgramResult {
    let [stake_account, from_account, signer_account, mint_account, token_program, system_program] =
        accounts
    else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !signer_account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    if *token_program.key != spl_token_2022::id() || *system_program.key != system_program::id() {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Verify stake PDA
    let (stake_pda_key, stake_bump) =
        Pubkey::find_program_address(&amp;[STAKE_PDA_SEED, signer_account.key.as_ref()], program_id);

    if stake_pda_key != *stake_account.key {
        return Err(ProgramError::InvalidSeeds);
    }

    // Create stake account if it doesn't exist
    if stake_account.data_is_empty() || *stake_account.owner != spl_token_2022::id() {
        let space_required = TokenAccount::get_packed_len();
        let lamports_required = Rent::get()?.minimum_balance(space_required);

        invoke_signed(
            &amp;system_instruction::create_account(
                signer_account.key,
                stake_account.key,
                lamports_required,
                space_required as u64,
                &amp;spl_token_2022::id(),
            ),
            &amp;[
                signer_account.clone(),
                stake_account.clone(),
                system_program.clone(),
            ],
            &amp;[&amp;[STAKE_PDA_SEED, signer_account.key.as_ref(), &amp;[stake_bump]]],
        )?;

        // Initialize the stake token account
        invoke_signed(
            &amp;token_instruction::initialize_account3(
                &amp;spl_token_2022::id(),
                stake_account.key,
                mint_account.key,
                stake_account.key,
            )?,
            &amp;[stake_account.clone(), mint_account.clone()],
            &amp;[&amp;[STAKE_PDA_SEED, signer_account.key.as_ref(), &amp;[stake_bump]]],
        )?;
    }

    // Transfer tokens from user's account to stake account
    invoke(
        &amp;token_instruction::transfer_checked(
            &amp;spl_token_2022::id(),
            from_account.key,
            mint_account.key,
            stake_account.key,
            signer_account.key,
            &amp;[],
            amount,
            DECIMALS,
        )?,
        &amp;[
            from_account.clone(),
            mint_account.clone(),
            stake_account.clone(),
            signer_account.clone(),
        ],
    )?;

    Ok(())
}

fn process_unstake(program_id: &amp;Pubkey, accounts: &amp;[AccountInfo], amount: u64) -&gt; ProgramResult {
    let [stake_account, unstake_to_account, signer_account, mint_account, token_program, system_program] =
        accounts
    else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !signer_account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    if *token_program.key != spl_token_2022::id() || *system_program.key != system_program::id() {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Verify stake PDA
    let (stake_pda_key, stake_bump) =
        Pubkey::find_program_address(&amp;[STAKE_PDA_SEED, signer_account.key.as_ref()], program_id);

    if stake_pda_key != *stake_account.key {
        return Err(ProgramError::InvalidSeeds);
    }

    // Transfer tokens from stake account to user's account
    invoke_signed(
        &amp;token_instruction::transfer_checked(
            &amp;spl_token_2022::id(),
            stake_account.key,
            mint_account.key,
            unstake_to_account.key,
            stake_account.key,
            &amp;[],
            amount,
            DECIMALS,
        )?,
        &amp;[
            stake_account.clone(),
            mint_account.clone(),
            unstake_to_account.clone(),
            stake_account.clone(),
        ],
        &amp;[&amp;[STAKE_PDA_SEED, signer_account.key.as_ref(), &amp;[stake_bump]]],
    )?;

    Ok(())
}</code></pre>
<h4 id="anchor-5"><a class="header" href="#anchor-5">Anchor</a></h4>
<pre><code class="language-rust">#[program]
pub mod fungible_tokens {
    use super::*;

    pub fn initialize(ctx: Context&lt;Initialize&gt;) -&gt; Result&lt;()&gt; {
        mint_to(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                MintTo {
                    mint: ctx.accounts.mint.to_account_info(),
                    to: ctx.accounts.mint_supply_to.to_account_info(),
                    authority: ctx.accounts.mint.to_account_info(),
                },
                &amp;[&amp;[MINT_PDA_SEED, &amp;[ctx.bumps.mint]]],
            ),
            TOTAL_SUPPLY,
        )?;

        Ok(())
    }

    pub fn stake(ctx: Context&lt;Stake&gt;, amount: u64) -&gt; Result&lt;()&gt; {
        transfer_checked(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                TransferChecked {
                    from: ctx.accounts.from_account.to_account_info(),
                    mint: ctx.accounts.mint.to_account_info(),
                    to: ctx.accounts.stake_account.to_account_info(),
                    authority: ctx.accounts.signer.to_account_info(),
                },
            ),
            amount,
            DECIMALS,
        )?;

        Ok(())
    }

    pub fn unstake(ctx: Context&lt;Unstake&gt;, amount: u64) -&gt; Result&lt;()&gt; {
        transfer_checked(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                TransferChecked {
                    from: ctx.accounts.stake_account.to_account_info(),
                    mint: ctx.accounts.mint.to_account_info(),
                    to: ctx.accounts.unstake_to_account.to_account_info(),
                    authority: ctx.accounts.signer.to_account_info(),
                },
                &amp;[&amp;[STAKE_PDA_SEED, &amp;[ctx.bumps.stake_account]]],
            ),
            amount,
            DECIMALS,
        )?;

        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize&lt;'info&gt; {
    #[account(
        init,
        payer = signer,
        mint::decimals = DECIMALS,
        mint::authority = mint.key(),
        mint::freeze_authority = mint.key(),
        seeds = [MINT_PDA_SEED],
        bump
    )]
    pub mint: InterfaceAccount&lt;'info, Mint&gt;,
    #[account(
        init,
        payer = signer,
        associated_token::mint = mint,
        associated_token::authority = signer,
        associated_token::token_program = token_program,
    )]
    pub mint_supply_to: InterfaceAccount&lt;'info, TokenAccount&gt;,
    #[account(mut)]
    pub signer: Signer&lt;'info&gt;,
    pub token_program: Interface&lt;'info, TokenInterface&gt;,
    pub associated_token_program: Program&lt;'info, AssociatedToken&gt;,
    pub system_program: Program&lt;'info, System&gt;,
}

#[derive(Accounts)]
pub struct Stake&lt;'info&gt; {
    #[account(
        init_if_needed,
        payer = signer,
        token::mint = mint,
        token::authority = stake_account,
        token::token_program = token_program,
        seeds = [b"stake", signer.key.as_ref()],
        bump
    )]
    pub stake_account: InterfaceAccount&lt;'info, TokenAccount&gt;,
    #[account(mut)]
    pub from_account: InterfaceAccount&lt;'info, TokenAccount&gt;,
    #[account(mut)]
    pub signer: Signer&lt;'info&gt;,
    pub mint: InterfaceAccount&lt;'info, Mint&gt;,
    pub token_program: Interface&lt;'info, TokenInterface&gt;,
    pub system_program: Program&lt;'info, System&gt;,
}

#[derive(Accounts)]
pub struct Unstake&lt;'info&gt; {
    #[account(
        mut,
        seeds = [b"stake", signer.key.as_ref()],
        bump
    )]
    pub stake_account: InterfaceAccount&lt;'info, TokenAccount&gt;,
    #[account(mut)]
    pub unstake_to_account: InterfaceAccount&lt;'info, TokenAccount&gt;,
    #[account(mut)]
    pub signer: Signer&lt;'info&gt;,
    pub mint: InterfaceAccount&lt;'info, Mint&gt;,
    pub token_program: Interface&lt;'info, TokenInterface&gt;,
    pub system_program: Program&lt;'info, System&gt;,
}</code></pre>
<h2 id="stylus-2"><a class="header" href="#stylus-2">Stylus</a></h2>
<p>Stylus tokens follow the ERC-20 standard: each token is a self-contained contract storing balances in mappings and implementing transfer logic directly. Token operations are direct method calls to the contract. The standard interface - <code>transfer</code>, <code>approve</code>, <code>transferFrom</code> - enables application composability, while contracts extend functionality through inheritance. OpenZeppelin's Stylus implementations provide components for minting caps, contract pausing, and access control. Before implementing custom token functionality, it is best practice to check if an existing <a href="https://docs.rs/openzeppelin-stylus/latest/openzeppelin_stylus/token/index.html">standard</a> or their <a href="https://docs.rs/openzeppelin-stylus/latest/openzeppelin_stylus/token/erc20/extensions/index.html">extensions</a> fits the use case.</p>
<pre><code class="language-rust">use openzeppelin_stylus::token::erc20::{Erc20, Error as Erc20Error, IErc20};

sol! {
    #[derive(Debug)]
    error InsufficientStakedBalance(address account, uint256 staked_balance);
}

#[derive(SolidityError, Debug)]
pub enum ContractError {
    InsufficientStakedBalance(InsufficientStakedBalance),
}

#[storage]
#[entrypoint]
pub struct FungibleTokenContract {
    erc20: Erc20,
    staked_balance: StorageMap&lt;Address, StorageU256&gt;,
}

#[public]
#[implements(IErc20&lt;Error = Erc20Error&gt;)]
impl FungibleTokenContract {
    #[constructor]
    pub fn constructor(&amp;mut self, mint_to: Address) -&gt; Result&lt;(), Erc20Error&gt; {
        assert_ne!(mint_to, Address::ZERO, "mint_to cannot be a zero-address");

        self.erc20._mint(mint_to, U256::from(TOTAL_SUPPLY))?;

        Ok(())
    }

    pub fn stake(&amp;mut self, amount: U256) -&gt; Result&lt;(), Erc20Error&gt; {
        let msg_sender = self.vm().msg_sender();

        let staked_balance = self.staked_balance_of(msg_sender);

        // Overflow not possible:
        // `amount` + `staked_balance` &lt;= `total_supply` &lt; `U256::MAX`
        self.staked_balance
            .setter(msg_sender)
            .set(staked_balance + amount);

        // Returns `ERC20InsufficientBalance` if `from_balance` &lt; `amount`
        self.erc20
            ._update(msg_sender, self.vm().contract_address(), amount)
    }

    pub fn unstake(&amp;mut self, amount: U256) -&gt; Result&lt;(), ContractError&gt; {
        let msg_sender = self.vm().msg_sender();

        let staked_balance = self.staked_balance_of(msg_sender);

        if staked_balance &lt; amount {
            return Err(InsufficientStakedBalance {
                account: msg_sender,
                staked_balance,
            }
            .into());
        }

        // Overflow not possible:
        // `amount` &lt;= `staked_balance`
        self.staked_balance
            .setter(msg_sender)
            .set(staked_balance - amount);

        self.erc20
            ._update(self.vm().contract_address(), msg_sender, amount)
            .expect("amount &lt;= staked_balance");

        Ok(())
    }

    pub fn staked_balance_of(&amp;self, account: Address) -&gt; U256 {
        self.staked_balance.get(account)
    }

    pub fn decimals(&amp;self) -&gt; U8 {
        U8::from(DECIMALS)
    }
}

#[public]
impl IErc20 for FungibleTokenContract {
    type Error = Erc20Error;

    fn total_supply(&amp;self) -&gt; U256 {
        self.erc20.total_supply()
    }

    fn balance_of(&amp;self, account: Address) -&gt; U256 {
        self.erc20.balance_of(account)
    }

    fn transfer(&amp;mut self, to: Address, value: U256) -&gt; Result&lt;bool, Self::Error&gt; {
        self.erc20.transfer(to, value)
    }

    fn allowance(&amp;self, owner: Address, spender: Address) -&gt; U256 {
        self.erc20.allowance(owner, spender)
    }

    fn approve(&amp;mut self, spender: Address, value: U256) -&gt; Result&lt;bool, Self::Error&gt; {
        self.erc20.approve(spender, value)
    }

    fn transfer_from(
        &amp;mut self,
        from: Address,
        to: Address,
        value: U256,
    ) -&gt; Result&lt;bool, Self::Error&gt; {
        self.erc20.transfer_from(from, to, value)
    }
}</code></pre>
<h3 id="allowance-system"><a class="header" href="#allowance-system">Allowance system</a></h3>
<p>The allowance mechanism is central to ERC-20: users approve contracts to spend tokens on their behalf, then contracts pull tokens using <a href="https://docs.rs/openzeppelin-stylus/latest/openzeppelin_stylus/token/erc20/trait.IErc20.html#tymethod.transfer_from"><code>IERC20::transfer_from</code></a>. This pull-based model is fundamental to DeFi composability on EVM chains.</p>
<p>In order for Stylus contracts to receive ERC20 tokens from a user, the user must first grant them an allowance to transfer a pre-determined maximum amount of tokens.</p>
<pre><code class="language-rust">sol! {
    #[derive(Debug)]
    error InsufficientStakedBalance(address account, uint256 staked_balance);
}

#[derive(SolidityError, Debug)]
pub enum ContractError {
    InsufficientStakedBalance(InsufficientStakedBalance),
}

#[storage]
#[entrypoint]
pub struct StakeErc20Contract {
    stake_token: StorageAddress,
    staked_balance: StorageMap&lt;Address, StorageU256&gt;,
}

impl StakeErc20Contract {
    fn stake_token(&amp;self) -&gt; Erc20Interface {
        Erc20Interface::new(self.stake_token.get())
    }
}

#[public]
impl StakeErc20Contract {
    #[constructor]
    pub fn constructor(&amp;mut self, stake_token: Address) {
        self.stake_token.set(stake_token);
    }

    pub fn stake(&amp;mut self, amount: U256) -&gt; Result&lt;(), Vec&lt;u8&gt;&gt; {
        let msg_sender = self.vm().msg_sender();

        let staked_balance = self.staked_balance_of(msg_sender);

        // Overflow not possible:
        // `amount` + `staked_balance` &lt;= `total_supply` &lt; `U256::MAX`
        self.staked_balance
            .setter(msg_sender)
            .set(staked_balance + amount);

        // Reverts with `ERC20InsufficientBalance` if `from_balance` &lt; `amount` or
        // `ERC20InsufficientAllowance` if `contract_allowance` &lt; `amount`
        let contract_addr = self.vm().contract_address();
        self.stake_token()
            .transfer_from(self, msg_sender, contract_addr, amount)?;

        Ok(())
    }

    pub fn unstake(&amp;mut self, amount: U256) -&gt; Result&lt;(), ContractError&gt; {
        let msg_sender = self.vm().msg_sender();

        let staked_balance = self.staked_balance_of(msg_sender);

        if staked_balance &lt; amount {
            return Err(InsufficientStakedBalance {
                account: msg_sender,
                staked_balance,
            }
            .into());
        }

        // Overflow not possible:
        // `amount` &lt;= `staked_balance`
        self.staked_balance
            .setter(msg_sender)
            .set(staked_balance - amount);

        self.stake_token()
            .transfer(self, msg_sender, amount)
            .expect("amount &lt;= staked_balance");

        Ok(())
    }

    pub fn staked_balance_of(&amp;self, account: Address) -&gt; U256 {
        self.staked_balance.get(account)
    }
}</code></pre>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<p>With fungible tokens covered, the next chapter explores <a href="./non-fungible-tokens.html">Non-Fungible Token Handling</a> - migrating from Metaplex NFTs to ERC-721 patterns in Stylus.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-fungible-token-handling"><a class="header" href="#non-fungible-token-handling">Non-Fungible Token Handling</a></h1>
<p>Solana's NFT ecosystem primarily uses the Metaplex Token Metadata standard for non-fungible tokens. This chapter covers migrating Metaplex NFT operations to ERC-721 patterns in Stylus, including minting, transfers, approvals, and metadata management.</p>
<p>To illustrate NFT operations comprehensively, we will implement a contract that creates a complete NFT collection with minting, metadata, and transfer capabilities.</p>
<h2 id="solana-3"><a class="header" href="#solana-3">Solana</a></h2>
<p>Solana NFTs use the Metaplex Token Metadata Program built on top of SPL Tokens. Each NFT requires three accounts: a mint account (SPL Token with supply of 1), a metadata account (storing name, symbol, URI), and optionally a master edition account (marking it as an NFT). Programs interact with NFTs through CPIs to both the SPL Token and Metaplex programs. Collections use a collection NFT that individual NFTs reference. Creators and royalties are stored on-chain in the metadata. Token Metadata v2 adds programmable NFTs with rule sets for transfer restrictions and utility uses.</p>
<h4 id="native-6"><a class="header" href="#native-6">Native</a></h4>
<pre><code class="language-rust">#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum Instruction {
    CreateNameCollection,
    MintNameNft { name: String },
}

pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    if !check_id(program_id) {
        return Err(ProgramError::IncorrectProgramId);
    }

    let instruction = Instruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    match instruction {
        Instruction::CreateNameCollection =&gt; process_create_name_collection(program_id, accounts),
        Instruction::MintNameNft { name } =&gt; process_mint_name_nft(program_id, accounts, name),
    }
}

fn process_create_name_collection(program_id: &amp;Pubkey, accounts: &amp;[AccountInfo]) -&gt; ProgramResult {
    msg!("Create Name Collection");

    let [authority, collection_mint, collection_metadata, collection_master_edition, collection_token, system_program, token_program, associated_token_program, token_metadata_program, rent_sysvar] =
        accounts
    else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !authority.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Verify program IDs
    if *system_program.key != system_program::id()
        || *token_program.key != spl_token_2022::id()
        || *associated_token_program.key != spl_associated_token_account::id()
        || *token_metadata_program.key != mpl_token_metadata::ID
        || *rent_sysvar.key != rent::sysvar::id()
    {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Derive and verify collection mint PDA
    let (collection_mint_key, collection_bump) =
        Pubkey::find_program_address(&amp;[COLLECTION_SEED], program_id);

    if collection_mint_key != *collection_mint.key {
        return Err(ProgramError::InvalidSeeds);
    }

    // Check if collection mint already exists
    if !collection_mint.data_is_empty() || *collection_mint.owner == spl_token_2022::id() {
        return Err(ProgramError::AccountAlreadyInitialized);
    }

    // Verify collection token account
    let expected_collection_token =
        spl_associated_token_account::get_associated_token_address_with_program_id(
            authority.key,
            &amp;collection_mint_key,
            &amp;spl_token_2022::id(),
        );

    if expected_collection_token != *collection_token.key {
        return Err(ProgramError::InvalidAccountData);
    }

    // Verify metadata account
    let (expected_metadata, _) = Pubkey::find_program_address(
        &amp;[
            b"metadata",
            &amp;mpl_token_metadata::ID.to_bytes(),
            &amp;collection_mint_key.to_bytes(),
        ],
        &amp;mpl_token_metadata::ID,
    );

    if expected_metadata != *collection_metadata.key {
        return Err(ProgramError::InvalidAccountData);
    }

    // Verify master edition account
    let (expected_edition, _) = Pubkey::find_program_address(
        &amp;[
            b"metadata",
            &amp;mpl_token_metadata::ID.to_bytes(),
            &amp;collection_mint_key.to_bytes(),
            b"edition",
        ],
        &amp;mpl_token_metadata::ID,
    );

    if expected_edition != *collection_master_edition.key {
        return Err(ProgramError::InvalidAccountData);
    }

    let signer_seeds = &amp;[COLLECTION_SEED, &amp;[collection_bump]];

    // Create mint account
    let mint_space = Mint::get_packed_len();
    let mint_lamports = Rent::get()?.minimum_balance(mint_space);

    invoke_signed(
        &amp;system_instruction::create_account(
            authority.key,
            collection_mint.key,
            mint_lamports,
            mint_space as u64,
            &amp;spl_token_2022::id(),
        ),
        &amp;[
            authority.clone(),
            collection_mint.clone(),
            system_program.clone(),
        ],
        &amp;[signer_seeds],
    )?;

    msg!("Created Name Collection Mint Account");

    // Initialize mint with 0 decimals for NFT
    invoke_signed(
        &amp;token_instruction::initialize_mint(
            &amp;spl_token_2022::id(),
            collection_mint.key,
            collection_mint.key,
            Some(collection_mint.key),
            0,
        )?,
        &amp;[collection_mint.clone(), rent_sysvar.clone()],
        &amp;[signer_seeds],
    )?;

    msg!("Intitialized Name Collection Mint");

    // Create associated token account
    invoke(
        &amp;associated_token_instruction::create_associated_token_account(
            authority.key,
            authority.key,
            collection_mint.key,
            &amp;spl_token_2022::id(),
        ),
        &amp;[
            authority.clone(),
            collection_token.clone(),
            authority.clone(),
            collection_mint.clone(),
            system_program.clone(),
            token_program.clone(),
            associated_token_program.clone(),
        ],
    )?;

    msg!("Created Name Collection ATA");

    // Mint 1 token to the collection token account
    invoke_signed(
        &amp;token_instruction::mint_to(
            &amp;spl_token_2022::id(),
            collection_mint.key,
            collection_token.key,
            collection_mint.key,
            &amp;[],
            1,
        )?,
        &amp;[
            collection_mint.clone(),
            collection_token.clone(),
            collection_mint.clone(),
        ],
        &amp;[signer_seeds],
    )?;

    msg!("Minted Collection to ATA");

    // Create metadata account
    let creators = vec![Creator {
        address: *collection_mint.key,
        verified: true,
        share: 100,
    }];

    let create_metadata_ix = CreateMetadataAccountV3Builder::new()
        .metadata(*collection_metadata.key)
        .mint(*collection_mint.key)
        .mint_authority(*collection_mint.key)
        .payer(*authority.key)
        .update_authority(*collection_mint.key, true)
        .system_program(*system_program.key)
        .data(DataV2 {
            name: "Mock Name Service".to_string(),
            symbol: "MNS".to_string(),
            uri: String::new(),
            seller_fee_basis_points: 0,
            creators: Some(creators),
            collection: None,
            uses: None,
        })
        .is_mutable(true)
        .collection_details(CollectionDetails::V1 { size: 0 })
        .instruction();

    invoke_signed(
        &amp;create_metadata_ix,
        &amp;[
            collection_metadata.clone(),
            collection_mint.clone(),
            collection_mint.clone(),
            authority.clone(),
            collection_mint.clone(),
            system_program.clone(),
        ],
        &amp;[signer_seeds],
    )?;

    msg!("Created Name Collection Metadata");

    // Create master edition
    let create_edition_ix = CreateMasterEditionV3Builder::new()
        .edition(*collection_master_edition.key)
        .update_authority(*collection_mint.key)
        .mint_authority(*collection_mint.key)
        .mint(*collection_mint.key)
        .payer(*authority.key)
        .metadata(*collection_metadata.key)
        .token_program(*token_program.key)
        .system_program(*system_program.key)
        .max_supply(0)
        .instruction();

    invoke_signed(
        &amp;create_edition_ix,
        &amp;[
            collection_master_edition.clone(),
            collection_mint.clone(),
            collection_mint.clone(),
            collection_mint.clone(),
            authority.clone(),
            collection_metadata.clone(),
            token_program.clone(),
            system_program.clone(),
        ],
        &amp;[signer_seeds],
    )?;

    msg!("Created Name Collection Master Edition");

    Ok(())
}

fn process_mint_name_nft(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    name: String,
) -&gt; ProgramResult {
    let [owner, name_mint, name_token, name_metadata, name_master_edition, collection_mint, collection_metadata, collection_master_edition, system_program, token_program, associated_token_program, token_metadata_program, sysvar_instruction, rent_sysvar] =
        accounts
    else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !owner.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Validate name
    if name.is_empty() || name.len() &gt; MAX_NAME_LENGTH {
        return Err(ProgramError::InvalidArgument);
    }

    if !name.chars().all(|c| c.is_ascii_alphanumeric() || c == '_') {
        return Err(ProgramError::InvalidArgument);
    }

    // Verify program IDs
    if *system_program.key != system_program::id()
        || *token_program.key != spl_token_2022::id()
        || *associated_token_program.key != spl_associated_token_account::id()
        || *token_metadata_program.key != mpl_token_metadata::ID
        || *sysvar_instruction.key != solana_sdk_ids::sysvar::instructions::id()
    {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Derive and verify name mint PDA
    let (name_mint_key, name_bump) =
        Pubkey::find_program_address(&amp;[MINT_SEED, name.as_bytes()], program_id);

    if name_mint_key != *name_mint.key {
        return Err(ProgramError::InvalidSeeds);
    }

    // Check if name mint already exists
    if !name_mint.data_is_empty() || *name_mint.owner == spl_token_2022::id() {
        return Err(ProgramError::AccountAlreadyInitialized);
    }

    // Verify collection mint PDA
    let (collection_mint_key, collection_bump) =
        Pubkey::find_program_address(&amp;[COLLECTION_SEED], program_id);

    if collection_mint_key != *collection_mint.key {
        return Err(ProgramError::InvalidSeeds);
    }

    // Verify name token account
    let expected_name_token =
        spl_associated_token_account::get_associated_token_address_with_program_id(
            owner.key,
            &amp;name_mint_key,
            &amp;spl_token_2022::id(),
        );

    if expected_name_token != *name_token.key {
        return Err(ProgramError::InvalidAccountData);
    }

    // Verify metadata accounts
    let (expected_name_metadata, _) = Pubkey::find_program_address(
        &amp;[
            b"metadata",
            &amp;mpl_token_metadata::ID.to_bytes(),
            &amp;name_mint_key.to_bytes(),
        ],
        &amp;mpl_token_metadata::ID,
    );

    if expected_name_metadata != *name_metadata.key {
        return Err(ProgramError::InvalidAccountData);
    }

    let (expected_name_edition, _) = Pubkey::find_program_address(
        &amp;[
            b"metadata",
            &amp;mpl_token_metadata::ID.to_bytes(),
            &amp;name_mint_key.to_bytes(),
            b"edition",
        ],
        &amp;mpl_token_metadata::ID,
    );

    if expected_name_edition != *name_master_edition.key {
        return Err(ProgramError::InvalidAccountData);
    }

    let collection_signer_seeds = &amp;[COLLECTION_SEED, &amp;[collection_bump]];

    // Create name mint account
    let mint_space = Mint::get_packed_len();
    let mint_lamports = Rent::get()?.minimum_balance(mint_space);

    invoke_signed(
        &amp;system_instruction::create_account(
            owner.key,
            name_mint.key,
            mint_lamports,
            mint_space as u64,
            &amp;spl_token_2022::id(),
        ),
        &amp;[owner.clone(), name_mint.clone(), system_program.clone()],
        &amp;[&amp;[MINT_SEED, &amp;[name_bump]]],
    )?;

    // Initialize name mint with collection mint as authority
    invoke_signed(
        &amp;token_instruction::initialize_mint(
            &amp;spl_token_2022::id(),
            name_mint.key,
            collection_mint.key,
            Some(collection_mint.key),
            0,
        )?,
        &amp;[name_mint.clone(), rent_sysvar.clone()],
        &amp;[collection_signer_seeds],
    )?;

    // Create associated token account for name NFT
    invoke(
        &amp;associated_token_instruction::create_associated_token_account(
            owner.key,
            owner.key,
            name_mint.key,
            &amp;spl_token_2022::id(),
        ),
        &amp;[
            owner.clone(),
            name_token.clone(),
            owner.clone(),
            name_mint.clone(),
            system_program.clone(),
            token_program.clone(),
            associated_token_program.clone(),
        ],
    )?;

    // Mint 1 token
    invoke_signed(
        &amp;token_instruction::mint_to(
            &amp;spl_token_2022::id(),
            name_mint.key,
            name_token.key,
            collection_mint.key,
            &amp;[],
            1,
        )?,
        &amp;[
            name_mint.clone(),
            name_token.clone(),
            collection_mint.clone(),
        ],
        &amp;[collection_signer_seeds],
    )?;

    // Create metadata for name NFT
    let creators = vec![Creator {
        address: *collection_mint.key,
        verified: true,
        share: 100,
    }];

    let create_metadata_ix = CreateMetadataAccountV3Builder::new()
        .metadata(*name_metadata.key)
        .mint(*name_mint.key)
        .mint_authority(*collection_mint.key)
        .payer(*owner.key)
        .update_authority(*collection_mint.key, true)
        .system_program(*system_program.key)
        .data(DataV2 {
            name: name.clone(),
            symbol: "MSN".to_owned(),
            uri: String::new(),
            seller_fee_basis_points: 0,
            creators: Some(creators),
            collection: Some(Collection {
                verified: false,
                key: *collection_mint.key,
            }),
            uses: None,
        })
        .is_mutable(true)
        .instruction();

    invoke_signed(
        &amp;create_metadata_ix,
        &amp;[
            name_metadata.clone(),
            name_mint.clone(),
            collection_mint.clone(),
            owner.clone(),
            collection_mint.clone(),
            system_program.clone(),
        ],
        &amp;[collection_signer_seeds],
    )?;

    // Create master edition for name NFT
    let create_edition_ix = CreateMasterEditionV3Builder::new()
        .edition(*name_master_edition.key)
        .update_authority(*collection_mint.key)
        .mint_authority(*collection_mint.key)
        .mint(*name_mint.key)
        .payer(*owner.key)
        .metadata(*name_metadata.key)
        .token_program(*token_program.key)
        .system_program(*system_program.key)
        .max_supply(1)
        .instruction();

    invoke_signed(
        &amp;create_edition_ix,
        &amp;[
            name_master_edition.clone(),
            collection_mint.clone(),
            collection_mint.clone(),
            name_mint.clone(),
            owner.clone(),
            name_metadata.clone(),
            token_program.clone(),
            system_program.clone(),
        ],
        &amp;[collection_signer_seeds],
    )?;

    // Verify collection membership
    let verify_collection_ix = VerifyCollectionV1Builder::new()
        .authority(*collection_mint.key)
        .metadata(*name_metadata.key)
        .collection_mint(*collection_mint.key)
        .collection_metadata(Some(*collection_metadata.key))
        .collection_master_edition(Some(*collection_master_edition.key))
        .system_program(*system_program.key)
        .sysvar_instructions(*sysvar_instruction.key)
        .instruction();

    invoke_signed(
        &amp;verify_collection_ix,
        &amp;[
            collection_mint.clone(),
            name_metadata.clone(),
            collection_mint.clone(),
            collection_metadata.clone(),
            collection_master_edition.clone(),
            system_program.clone(),
            sysvar_instruction.clone(),
        ],
        &amp;[collection_signer_seeds],
    )?;

    Ok(())
}</code></pre>
<h4 id="anchor-6"><a class="header" href="#anchor-6">Anchor</a></h4>
<pre><code class="language-rust">#[program]
pub mod non_fungible_tokens {
    use super::*;

    pub fn create_name_collection(ctx: Context&lt;CreateNameCollection&gt;) -&gt; Result&lt;()&gt; {
        // Mint the collection NFT
        let seeds = &amp;[COLLECTION_SEED, &amp;[ctx.bumps.collection_mint]];
        let signer_seeds = &amp;[&amp;seeds[..]];

        mint_to(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                MintTo {
                    mint: ctx.accounts.collection_mint.to_account_info(),
                    to: ctx.accounts.collection_token.to_account_info(),
                    authority: ctx.accounts.collection_mint.to_account_info(),
                },
                signer_seeds,
            ),
            1,
        )?;
        msg!("Name Collection NFT minted!");

        // Create metadata account for the collection
        let creator = vec![Creator {
            address: ctx.accounts.collection_mint.key(),
            verified: true,
            share: 100,
        }];

        CreateMetadataAccountV3Cpi::new(
            &amp;ctx.accounts.token_metadata_program.to_account_info(),
            CreateMetadataAccountV3CpiAccounts {
                metadata: &amp;ctx.accounts.collection_metadata.to_account_info(),
                mint: &amp;ctx.accounts.collection_mint.to_account_info(),
                mint_authority: &amp;ctx.accounts.collection_mint.to_account_info(),
                payer: &amp;ctx.accounts.authority.to_account_info(),
                update_authority: (&amp;ctx.accounts.collection_mint.to_account_info(), true),
                system_program: &amp;ctx.accounts.system_program.to_account_info(),
                rent: None,
            },
            CreateMetadataAccountV3InstructionArgs {
                data: DataV2 {
                    name: "Mock Name Service".to_owned(),
                    symbol: "MNS".to_owned(),
                    uri: String::new(),
                    seller_fee_basis_points: 0,
                    creators: Some(creator),
                    collection: None,
                    uses: None,
                },
                is_mutable: true,
                collection_details: Some(CollectionDetails::V1 { size: 0 }),
            },
        )
        .invoke_signed(signer_seeds)?;

        // Create master edition for collection
        CreateMasterEditionV3Cpi::new(
            &amp;ctx.accounts.token_metadata_program.to_account_info(),
            CreateMasterEditionV3CpiAccounts {
                edition: &amp;ctx.accounts.collection_master_edition.to_account_info(),
                update_authority: &amp;ctx.accounts.collection_mint.to_account_info(),
                mint_authority: &amp;ctx.accounts.collection_mint.to_account_info(),
                mint: &amp;ctx.accounts.collection_mint.to_account_info(),
                payer: &amp;ctx.accounts.authority.to_account_info(),
                metadata: &amp;ctx.accounts.collection_metadata.to_account_info(),
                token_program: &amp;ctx.accounts.token_program.to_account_info(),
                system_program: &amp;ctx.accounts.system_program.to_account_info(),
                rent: None,
            },
            CreateMasterEditionV3InstructionArgs {
                max_supply: Some(0),
            },
        )
        .invoke_signed(signer_seeds)?;

        Ok(())
    }

    pub fn mint_name_nft(ctx: Context&lt;MintNameNFT&gt;, name: String) -&gt; Result&lt;()&gt; {
        require!(
            !name.is_empty() &amp;&amp; name.len() &lt;= MAX_NAME_LENGTH,
            ErrorCode::InvalidNameLength
        );
        require!(
            name.chars().all(|c| c.is_ascii_alphanumeric() || c == '_'),
            ErrorCode::InvalidNameCharacters
        );

        let collection_seeds = &amp;[COLLECTION_SEED, &amp;[ctx.bumps.collection_mint]];
        let collection_signer_seeds = &amp;[&amp;collection_seeds[..]];

        // Mint the Name NFT
        mint_to(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                MintTo {
                    mint: ctx.accounts.name_mint.to_account_info(),
                    to: ctx.accounts.name_token.to_account_info(),
                    authority: ctx.accounts.collection_mint.to_account_info(),
                },
                collection_signer_seeds,
            ),
            1,
        )?;

        // Create metadata with the name
        let creator = vec![Creator {
            address: ctx.accounts.collection_mint.key(),
            verified: true,
            share: 100,
        }];

        CreateMetadataAccountV3Cpi::new(
            &amp;ctx.accounts.token_metadata_program.to_account_info(),
            CreateMetadataAccountV3CpiAccounts {
                metadata: &amp;ctx.accounts.name_metadata.to_account_info(),
                mint: &amp;ctx.accounts.name_mint.to_account_info(),
                mint_authority: &amp;ctx.accounts.collection_mint.to_account_info(),
                payer: &amp;ctx.accounts.owner.to_account_info(),
                update_authority: (&amp;ctx.accounts.collection_mint.to_account_info(), true),
                system_program: &amp;ctx.accounts.system_program.to_account_info(),
                rent: None,
            },
            CreateMetadataAccountV3InstructionArgs {
                data: DataV2 {
                    name,
                    symbol: "MSN".to_owned(),
                    uri: String::new(),
                    seller_fee_basis_points: 0,
                    creators: Some(creator),
                    collection: Some(Collection {
                        verified: false,
                        key: ctx.accounts.collection_mint.key(),
                    }),
                    uses: None,
                },
                is_mutable: true,
                collection_details: None,
            },
        )
        .invoke_signed(collection_signer_seeds)?;

        // Create master edition for the name NFT
        CreateMasterEditionV3Cpi::new(
            &amp;ctx.accounts.token_metadata_program.to_account_info(),
            CreateMasterEditionV3CpiAccounts {
                edition: &amp;ctx.accounts.name_master_edition.to_account_info(),
                update_authority: &amp;ctx.accounts.collection_mint.to_account_info(),
                mint_authority: &amp;ctx.accounts.collection_mint.to_account_info(),
                mint: &amp;ctx.accounts.name_mint.to_account_info(),
                payer: &amp;ctx.accounts.owner.to_account_info(),
                metadata: &amp;ctx.accounts.name_metadata.to_account_info(),
                token_program: &amp;ctx.accounts.token_program.to_account_info(),
                system_program: &amp;ctx.accounts.system_program.to_account_info(),
                rent: None,
            },
            CreateMasterEditionV3InstructionArgs {
                max_supply: Some(0),
            },
        )
        .invoke_signed(collection_signer_seeds)?;

        // Verify collection membership
        VerifyCollectionV1Cpi::new(
            &amp;ctx.accounts.token_metadata_program.to_account_info(),
            VerifyCollectionV1CpiAccounts {
                authority: &amp;ctx.accounts.collection_mint.to_account_info(),
                delegate_record: None,
                metadata: &amp;ctx.accounts.name_metadata.to_account_info(),
                collection_mint: &amp;ctx.accounts.collection_mint.to_account_info(),
                collection_metadata: Some(&amp;ctx.accounts.collection_metadata.to_account_info()),
                collection_master_edition: Some(
                    &amp;ctx.accounts.collection_master_edition.to_account_info(),
                ),
                system_program: &amp;ctx.accounts.system_program.to_account_info(),
                sysvar_instructions: &amp;ctx.accounts.sysvar_instruction.to_account_info(),
            },
        )
        .invoke_signed(collection_signer_seeds)?;

        Ok(())
    }
}

#[derive(Accounts)]
pub struct CreateNameCollection&lt;'info&gt; {
    #[account(mut)]
    pub authority: Signer&lt;'info&gt;,

    #[account(
        init,
        payer = authority,
        mint::decimals = 0,
        mint::authority = collection_mint.key(),
        mint::freeze_authority = collection_mint.key(),
        seeds = [COLLECTION_SEED],
        bump,
    )]
    pub collection_mint: Account&lt;'info, Mint&gt;,

    #[account(mut)]
    /// CHECK: This account will be initialized by the metaplex program
    pub collection_metadata: UncheckedAccount&lt;'info&gt;,

    #[account(mut)]
    /// CHECK: This account will be initialized by the metaplex program
    pub collection_master_edition: UncheckedAccount&lt;'info&gt;,

    #[account(
        init,
        payer = authority,
        associated_token::mint = collection_mint,
        associated_token::authority = authority
    )]
    pub collection_token: Account&lt;'info, TokenAccount&gt;,

    pub system_program: Program&lt;'info, System&gt;,
    pub token_program: Program&lt;'info, Token&gt;,
    pub associated_token_program: Program&lt;'info, AssociatedToken&gt;,
    pub token_metadata_program: Program&lt;'info, Metadata&gt;,
}

#[derive(Accounts)]
#[instruction(name: String)]
pub struct MintNameNFT&lt;'info&gt; {
    #[account(mut)]
    pub owner: Signer&lt;'info&gt;,

    #[account(
        init,
        payer = owner,
        mint::decimals = 0,
        mint::authority = collection_mint,
        mint::freeze_authority = collection_mint,
        seeds = [MINT_SEED, name.as_bytes()],
        bump,
    )]
    pub name_mint: Account&lt;'info, Mint&gt;,

    #[account(
        init,
        payer = owner,
        associated_token::mint = name_mint,
        associated_token::authority = owner
    )]
    pub name_token: Account&lt;'info, TokenAccount&gt;,

    #[account(mut)]
    /// CHECK: This account will be initialized by the metaplex program
    pub name_metadata: UncheckedAccount&lt;'info&gt;,

    #[account(mut)]
    /// CHECK: This account will be initialized by the metaplex program
    pub name_master_edition: UncheckedAccount&lt;'info&gt;,

    // Collection accounts for verification
    #[account(
        mut,
        seeds = [COLLECTION_SEED],
        bump,
    )]
    pub collection_mint: Account&lt;'info, Mint&gt;,

    #[account(mut)]
    pub collection_metadata: Account&lt;'info, MetadataAccount&gt;,

    pub collection_master_edition: Account&lt;'info, MasterEditionAccount&gt;,

    // System accounts
    pub system_program: Program&lt;'info, System&gt;,
    pub token_program: Program&lt;'info, Token&gt;,
    pub associated_token_program: Program&lt;'info, AssociatedToken&gt;,
    pub token_metadata_program: Program&lt;'info, Metadata&gt;,

    #[account(address = solana_sdk_ids::sysvar::instructions::ID)]
    /// CHECK: Sysvar instruction account that is being checked with an address constraint
    pub sysvar_instruction: UncheckedAccount&lt;'info&gt;,
}</code></pre>
<h2 id="stylus-3"><a class="header" href="#stylus-3">Stylus</a></h2>
<p>Stylus NFTs follow the ERC-721 standard: each collection is a single contract managing all tokens through internal mappings. Token ownership, approvals, and metadata are stored directly in contract storage. The standard interface - <code>ownerOf</code>, <code>approve</code>, <code>transferFrom</code> - ensures marketplace compatibility. Contracts extend base functionality through modular patterns. OpenZeppelin's Stylus implementations provide components for enumeration, metadata URIs, and royalties. The single-contract model simplifies collection management compared to Solana's multi-account approach.</p>
<pre><code class="language-rust">sol! {
    #[derive(Debug)]
    error InvalidNameLength();

    #[derive(Debug)]
    error InvalidNameCharacters();

    #[derive(Debug)]
    error NameAlreadyMinted();
}

#[derive(SolidityError, Debug)]
pub enum ContractError {
    InvalidNameLength(InvalidNameLength),
    InvalidNameCharacters(InvalidNameCharacters),
    NameAlreadyMinted(NameAlreadyMinted),
    Erc721(erc721::Error),
}

#[storage]
#[entrypoint]
pub struct NameCollectionContract {
    erc721: Erc721,
    metadata: Erc721Metadata,
    // Map names to token ID
    minted_names: StorageMap&lt;String, StorageU256&gt;,
    // Map token ID to name
    token_names: StorageMap&lt;U256, StorageString&gt;,
    // track supply
    next_token_id: StorageU256,
}

#[public]
#[implements(IErc721&lt;Error = erc721::Error&gt;, IErc721Metadata&lt;Error = erc721::Error&gt;, IErc165)]
impl NameCollectionContract {
    #[constructor]
    pub fn constructor(&amp;mut self) -&gt; Result&lt;(), ContractError&gt; {
        // Initialize the collection metadata
        self.metadata
            .constructor("Mock Name Service".into(), "MNS".into());
        self.next_token_id.set(U256::ONE);
        Ok(())
    }

    pub fn mint_name_nft(&amp;mut self, to: Address, name: String) -&gt; Result&lt;U256, ContractError&gt; {
        // Validate name length
        if name.is_empty() || name.len() &gt; MAX_NAME_LENGTH {
            return Err(ContractError::InvalidNameLength(InvalidNameLength {}));
        }

        // Validate name characters (alphanumeric and underscore only)
        if !name.chars().all(|c| c.is_ascii_alphanumeric() || c == '_') {
            return Err(ContractError::InvalidNameCharacters(
                InvalidNameCharacters {},
            ));
        }

        // Check if name is already minted
        if self.is_name_minted(name.clone()) {
            return Err(NameAlreadyMinted {}.into());
        }

        // Get next token ID
        let token_id = self.next_token_id.get();

        // Mint the NFT
        self.erc721._mint(to, token_id)?;

        // Set the bi-directional name mapping
        self.minted_names.setter(name.clone()).set(token_id);
        self.token_names.setter(token_id).set_str(&amp;name);

        // Increment token ID for next mint
        self.next_token_id.set(token_id + U256::from(1));

        Ok(token_id)
    }

    pub fn get_token_id_by_name(&amp;self, name: String) -&gt; U256 {
        self.minted_names.get(name)
    }

    pub fn get_name_by_token_id(&amp;self, token_id: U256) -&gt; String {
        self.token_names.getter(token_id).get_string()
    }

    pub fn is_name_minted(&amp;self, name: String) -&gt; bool {
        self.minted_names.get(name) &gt; U256::ZERO
    }

    pub fn total_minted(&amp;self) -&gt; U256 {
        self.next_token_id.get() - U256::ONE
    }
}

#[public]
impl IErc721 for NameCollectionContract {
    type Error = erc721::Error;

    fn balance_of(&amp;self, owner: Address) -&gt; Result&lt;U256, Self::Error&gt; {
        self.erc721.balance_of(owner)
    }

    fn owner_of(&amp;self, token_id: U256) -&gt; Result&lt;Address, Self::Error&gt; {
        self.erc721.owner_of(token_id)
    }

    fn safe_transfer_from(
        &amp;mut self,
        from: Address,
        to: Address,
        token_id: U256,
    ) -&gt; Result&lt;(), Self::Error&gt; {
        self.erc721.safe_transfer_from(from, to, token_id)
    }

    fn safe_transfer_from_with_data(
        &amp;mut self,
        from: Address,
        to: Address,
        token_id: U256,
        data: Bytes,
    ) -&gt; Result&lt;(), Self::Error&gt; {
        self.erc721
            .safe_transfer_from_with_data(from, to, token_id, data)
    }

    fn transfer_from(
        &amp;mut self,
        from: Address,
        to: Address,
        token_id: U256,
    ) -&gt; Result&lt;(), Self::Error&gt; {
        self.erc721.transfer_from(from, to, token_id)
    }

    fn approve(&amp;mut self, to: Address, token_id: U256) -&gt; Result&lt;(), Self::Error&gt; {
        self.erc721.approve(to, token_id)
    }

    fn set_approval_for_all(&amp;mut self, to: Address, approved: bool) -&gt; Result&lt;(), Self::Error&gt; {
        self.erc721.set_approval_for_all(to, approved)
    }

    fn get_approved(&amp;self, token_id: U256) -&gt; Result&lt;Address, Self::Error&gt; {
        self.erc721.get_approved(token_id)
    }

    fn is_approved_for_all(&amp;self, owner: Address, operator: Address) -&gt; bool {
        self.erc721.is_approved_for_all(owner, operator)
    }
}

#[public]
impl IErc721Metadata for NameCollectionContract {
    type Error = erc721::Error;

    fn name(&amp;self) -&gt; String {
        self.metadata.name()
    }

    fn symbol(&amp;self) -&gt; String {
        self.metadata.symbol()
    }

    /// unused
    fn token_uri(&amp;self, _token_id: U256) -&gt; Result&lt;String, Self::Error&gt; {
        Ok(String::new())
    }
}

#[public]
impl IErc165 for NameCollectionContract {
    fn supports_interface(&amp;self, interface_id: B32) -&gt; bool {
        self.erc721.supports_interface(interface_id)
            || &lt;Self as IErc721Metadata&gt;::interface_id() == interface_id
    }
}</code></pre>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<p>With non-fungible tokens covered, the next chapter explores <a href="./errors-events.html">Errors and Events</a> - migrating Solana's logging and error patterns to Stylus structured events and custom errors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-8-errors-and-events"><a class="header" href="#chapter-8-errors-and-events">Chapter 8: Errors and Events</a></h1>
<p>Proper error reporting and event emission are crucial for robust smart contracts and user experience. This chapter covers migrating from Solana's <code>msg!()</code> logging and <code>ProgramError</code> type to Stylus's structured events and custom error types.</p>
<h2 id="errors"><a class="header" href="#errors">Errors</a></h2>
<h3 id="solana-4"><a class="header" href="#solana-4">Solana</a></h3>
<p>The error type used for all Solana programs is <a href="https://docs.rs/solana-program/latest/solana_program/program_error/enum.ProgramError.html"><code>solana_program::program_error::ProgramError</code></a> which is defined as:</p>
<pre><code class="language-rust">pub enum ProgramError {
    /// Allows on-chain programs to implement program-specific error types and see them returned
    /// by the Solana runtime. A program-specific error may be any type that is represented as
    /// or serialized to a u32 integer.
    Custom(u32),
    InvalidArgument,
    InvalidInstructionData,
    InvalidAccountData,
    AccountDataTooSmall,
    InsufficientFunds,
    IncorrectProgramId,
    MissingRequiredSignature,
    AccountAlreadyInitialized,
    UninitializedAccount,
    NotEnoughAccountKeys,
    AccountBorrowFailed,
    MaxSeedLengthExceeded,
    InvalidSeeds,
    BorshIoError(String),
    AccountNotRentExempt,
    UnsupportedSysvar,
    IllegalOwner,
    MaxAccountsDataAllocationsExceeded,
    InvalidRealloc,
    MaxInstructionTraceLengthExceeded,
    BuiltinProgramsMustConsumeComputeUnits,
    InvalidAccountOwner,
    ArithmeticOverflow,
    Immutable,
    IncorrectAuthority,
}</code></pre>
<p>Many of these generic variants can be returned during account and instruction validation. The <code>Custom</code> variant can be used to return program-specific errors such as those arising from business logic. The user simply needs to be able to convert their custom error to a <code>u32</code> integer.</p>
<p>In native Solana programs, this is done like so:</p>
<pre><code class="language-rust">#[derive(BorshSerialize, BorshDeserialize)]
pub enum Instruction {
    InvalidAmount {},
    Unauthorized {},
}

#[derive(Debug, Clone, Copy)]
// allows casting to u32 for value enums (no associated data)
#[repr(u32)]
pub enum ErrorCode {
    InvalidAmount,
    Unauthorized,
}

impl From&lt;ErrorCode&gt; for ProgramError {
    fn from(value: ErrorCode) -&gt; Self {
        Self::Custom(value as _)
    }
}

pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    if !check_id(program_id) {
        return Err(ProgramError::IncorrectProgramId);
    }

    let Ok(ix) = Instruction::try_from_slice(instruction_data) else {
        return Err(ProgramError::InvalidInstructionData);
    };

    match ix {
        Instruction::InvalidAmount {} =&gt; process_invalid_value(accounts),
        Instruction::Unauthorized {} =&gt; process_unauthorized(accounts),
    }
}

fn process_invalid_value(_accounts: &amp;[AccountInfo]) -&gt; ProgramResult {
    Err(ErrorCode::InvalidAmount.into())
}

fn process_unauthorized(_accounts: &amp;[AccountInfo]) -&gt; ProgramResult {
    Err(ErrorCode::Unauthorized.into())
}</code></pre>
<p>If we expand the <code>entrypoint!</code> macro, we can see that ultimately the program returns a <code>u64</code> integer after processing an instruction:</p>
<pre><code class="language-rust">#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -&gt; u64 {
    let (program_id, accounts, instruction_data) = unsafe {
        ::solana_program_entrypoint::deserialize(input)
    };
    match process_instruction(program_id, &amp;accounts, instruction_data) {
        // returns 0 for success
        Ok(()) =&gt; ::solana_program_entrypoint::SUCCESS,
        // returns solana_program::program_error::ProgramError converted to u64
        // Every variant apart from Custom(_) is mapped to a value &gt; u32::MAX + 1
        // Custom(0) is converted to 1 &lt;&lt; 32, ensuring that every custom error: 0 &lt; error_code &lt;= u32::MAX + 1
        Err(error) =&gt; error.into(),
    }
}</code></pre>
<p>Anchor provides the <code>#[error_code]</code> macro to reduce the boilerplate required to setup custom errors. Custom errors can also be specified within constraint rules:</p>
<pre><code class="language-rust">#[program]
pub mod errors_events {
    use super::*;

    pub fn invalid_amount(_ctx: Context&lt;InvalidAmount&gt;) -&gt; Result&lt;()&gt; {
        Err(ErrorCode::InvalidAmount.into())
    }

    pub fn unauthorized(_ctx: Context&lt;Unauthorized&gt;) -&gt; Result&lt;()&gt; {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct InvalidAmount&lt;'info&gt; {
    #[account(mut)]
    pub signer: Signer&lt;'info&gt;,
    pub system_program: Program&lt;'info, System&gt;,
}

#[derive(Accounts)]
pub struct Unauthorized&lt;'info&gt; {
    #[account(mut, constraint = false @ ErrorCode::Unauthorized)]
    pub signer: Signer&lt;'info&gt;,
    pub system_program: Program&lt;'info, System&gt;,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Invalid amount: amount must be greater than 0")]
    InvalidAmount,
    #[msg("Unauthorized")]
    Unauthorized,
}</code></pre>
<p>The <code>#[error_code]</code> macro expands to:</p>
<pre><code class="language-rust">#[repr(u32)]
pub enum ErrorCode {
    InvalidAmount,
    Unauthorized,
}

impl ErrorCode {
    /// Gets the name of this [#enum_name].
    pub fn name(&amp;self) -&gt; String {
        match self {
            ErrorCode::InvalidAmount =&gt; "InvalidAmount".to_string(),
            ErrorCode::Unauthorized =&gt; "Unauthorized".to_string(),
        }
    }
}

impl From&lt;ErrorCode&gt; for u32 {
    fn from(e: ErrorCode) -&gt; u32 {
        e as u32 + anchor_lang::error::ERROR_CODE_OFFSET
    }
}

impl From&lt;ErrorCode&gt; for anchor_lang::error::Error {
    fn from(error_code: ErrorCode) -&gt; anchor_lang::error::Error {
        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
            error_name: error_code.name(),
            error_code_number: error_code.into(),
            error_msg: error_code.to_string(),
            error_origin: None,
            compared_values: None,
        })
    }
}

impl std::fmt::Display for ErrorCode {
    fn fmt(
        &amp;self,
        fmt: &amp;mut std::fmt::Formatter&lt;'_&gt;,
    ) -&gt; std::result::Result&lt;(), std::fmt::Error&gt; {
        match self {
            ErrorCode::InvalidAmount =&gt; {
                fmt.write_fmt(
                    format_args!("Invalid amount: amount must be greater than 0"),
                )
            }
            ErrorCode::Unauthorized =&gt; fmt.write_fmt(format_args!("Unauthorized")),
        }
    }
}</code></pre>
<p>Note that <code>anchor_lang::error::ERROR_CODE_OFFSET</code> is used to reserve space for Anchor's own custom errors.</p>
<p>Each instruction handler returns <code>Result&lt;T, anchor_lang::error::Error&gt;</code>. If a handler returns <code>Err(anchor_lang::error::Error)</code>, it is converted first to a <code>solana_program::error::ProgramError</code> before ultimately being returned as an integer, as shown in the macro expansion below:</p>
<pre><code class="language-rust">#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -&gt; u64 {
    let (program_id, accounts, instruction_data) = unsafe {
        ::solana_program_entrypoint::deserialize(input)
    };
    match entry(program_id, &amp;accounts, instruction_data) {
        Ok(()) =&gt; ::solana_program_entrypoint::SUCCESS,
        Err(error) =&gt; error.into(),
    }
}

pub fn entry&lt;'info&gt;(
    program_id: &amp;Pubkey,
    accounts: &amp;'info [AccountInfo&lt;'info&gt;],
    data: &amp;[u8],
) -&gt; anchor_lang::solana_program::entrypoint::ProgramResult {
    try_entry(program_id, accounts, data)
        .map_err(|e| {
            e.log();
            e.into()
        })
}

fn try_entry&lt;'info&gt;(
    program_id: &amp;Pubkey,
    accounts: &amp;'info [AccountInfo&lt;'info&gt;],
    data: &amp;[u8],
) -&gt; Result&lt;(), &gt; {
    if *program_id != ID {
        return Err(anchor_lang::error::ErrorCode::DeclaredProgramIdMismatch.into());
    }
    dispatch(program_id, accounts, data)
}</code></pre>
<h3 id="stylus-4"><a class="header" href="#stylus-4">Stylus</a></h3>
<p>In contrast to Solana programs, a Stylus contract entrypoint always returns either zero or one, where zero denotes a successful call and one signifies an error occurred. For a contract function with returns, <code>Result&lt;T, E&gt;</code>, the error type <code>E</code> is converted to a byte array and written to the return data buffer:</p>
<pre><code class="language-rust">#[no_mangle]
pub extern "C" fn user_entrypoint(len: usize) -&gt; usize {
    let host = stylus_sdk::host::VM(stylus_sdk::host::WasmVM {});
    if host.msg_reentrant() {
        return 1;
    }
    host.pay_for_memory_grow(0);
    let input = host.read_args(len);
    // Calls the stylus_sdk::abi::router_entrypoint function returning ArbResult aka Result&lt;Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;
    let (data, status) = match __stylus_struct_entrypoint(input, host.clone()) {
        Ok(data) =&gt; (data, 0),
        Err(data) =&gt; (data, 1),
    };
    host.flush_cache(false);
    host.write_result(&amp;data);
    status
}</code></pre>
<p>The <code>SolidityError</code> derive macro can be used to implement <code>From&lt;E&gt;</code> for <code>Vec&lt;u8&gt;</code> for the contract defined error type <code>E</code>:</p>
<pre><code class="language-rust">sol! {
    error InvalidAmount(uint256 expected, uint256 received);
    error Unauthorized(address account);
}

#[derive(SolidityError)]
pub enum ContractError {
    InvalidAmount(InvalidAmount),
    Unauthorized(Unauthorized),
}</code></pre>
<p>Note that there is not also a trait with the name <code>SolidityError</code> like most Rust derive macros, instead it expands to the following:</p>
<pre><code class="language-rust">impl From&lt;InvalidAmount&gt; for ContractError {
    fn from(value: InvalidAmount) -&gt; Self {
        ContractError::InvalidAmount(value)
    }
}

impl From&lt;Unauthorized&gt; for ContractError {
    fn from(value: Unauthorized) -&gt; Self {
        ContractError::Unauthorized(value)
    }
}

impl From&lt;ContractError&gt; for alloc::vec::Vec&lt;u8&gt; {
    fn from(err: ContractError) -&gt; Self {
        match err {
            ContractError::InvalidAmount(e) =&gt; stylus_sdk::call::MethodError::encode(e),
            ContractError::Unauthorized(e) =&gt; stylus_sdk::call::MethodError::encode(e),
        }
    }
}</code></pre>
<p>The derive macro expects an enum consisting on one or more unit variants containing a single type implementing the <a href="https://docs.rs/stylus-sdk/latest/stylus_sdk/call/trait.MethodError.html"><code>stylus_sdk::call::MethodError</code></a> trait. The <code>stylus_sdk::call::MethodError</code> has a <a href="https://docs.rs/stylus-sdk/latest/stylus_sdk/call/trait.MethodError.html#impl-MethodError-for-T">blanket implementation</a> for any type which also implements <a href="https://docs.rs/alloy-sol-types/0.8.20/alloy_sol_types/trait.SolError.html"><code>alloy_sol_types::SolError</code></a>. The <a href="https://docs.rs/alloy-sol-macro/0.8.20/alloy_sol_macro/macro.sol.html"><code>sol!</code></a> macro is the easiest way to define types that implement <code>SolError</code>.</p>
<p>The above mechanisms can be combined to allow Stylus contracts to return structured custom errors:</p>
<pre><code class="language-rust">#[storage]
#[entrypoint]
pub struct ErrorsEvents {}

sol! {
    error InvalidAmount(uint256 expected, uint256 received);
    error Unauthorized(address account);
}

#[derive(SolidityError)]
pub enum ContractError {
    InvalidAmount(InvalidAmount),
    Unauthorized(Unauthorized),
}

#[public]
impl ErrorsEvents {
    pub fn invalid_amount(&amp;mut self, expected: U256, received: U256) -&gt; Result&lt;(), ContractError&gt; {
        Err(InvalidAmount { expected, received }.into())
    }

    pub fn unauthorized(&amp;mut self) -&gt; Result&lt;(), ContractError&gt; {
        Err(Unauthorized {
            account: self.vm().msg_sender(),
        }
        .into())
    }
}</code></pre>
<h2 id="logging-and-events"><a class="header" href="#logging-and-events">Logging and events</a></h2>
<h3 id="solana-5"><a class="header" href="#solana-5">Solana</a></h3>
<p><a href="https://docs.rs/solana-program/latest/solana_program/log/index.html">Logging</a> in Solana is in the form of lines of free text. Due to the lack of standardized ABI for function selection and all errors being reduced to integers, Solana program logs are an important part of instruction execution auditing and tracking. Additionally, they are frequently used for debugging programs during the development process.</p>
<p>The following excerpt from the <a href="https://github.com/solana-program/token-2022/blob/57b3bcbd3c15de22db47ae2024fc73b43dafdd8a/program/src/processor.rs#L1637-L1945"><code>spl-token-2022</code></a> illustrates the convention of logging the name of the instruction being executed:</p>
<pre><code class="language-rust"> pub fn process(program_id: &amp;Pubkey, accounts: &amp;[AccountInfo], input: &amp;[u8]) -&gt; ProgramResult {
        if let Ok(instruction_type) = decode_instruction_type(input) {
            match instruction_type {
                PodTokenInstruction::InitializeMint =&gt; {
                    msg!("Instruction: InitializeMint");
                    let (data, freeze_authority) =
                        decode_instruction_data_with_coption_pubkey::&lt;InitializeMintData&gt;(input)?;
                    Self::process_initialize_mint(
                        accounts,
                        data.decimals,
                        &amp;data.mint_authority,
                        freeze_authority,
                    )
                }
                PodTokenInstruction::InitializeMint2 =&gt; {
                    msg!("Instruction: InitializeMint2");
                    let (data, freeze_authority) =
                        decode_instruction_data_with_coption_pubkey::&lt;InitializeMintData&gt;(input)?;
                    Self::process_initialize_mint2(
                        accounts,
                        data.decimals,
                        &amp;data.mint_authority,
                        freeze_authority,
                    )
                }
                PodTokenInstruction::InitializeAccount =&gt; {
                    msg!("Instruction: InitializeAccount");
                    Self::process_initialize_account(accounts)
                }
                // ...
                PodTokenInstruction::PausableExtension =&gt; {
                    msg!("Instruction: PausableExtension");
                    pausable::processor::process_instruction(program_id, accounts, &amp;input[1..])
                }
            }
        } else if let Ok(instruction) = TokenMetadataInstruction::unpack(input) {
            token_metadata::processor::process_instruction(program_id, accounts, instruction)
        } else if let Ok(instruction) = TokenGroupInstruction::unpack(input) {
            token_group::processor::process_instruction(program_id, accounts, instruction)
        } else {
            Err(TokenError::InvalidInstruction.into())
        }
    }
}</code></pre>
<p>Another common use is to provide additional context before returning errors, as can be seen in the <a href="https://github.com/metaplex-foundation/mpl-token-metadata/blob/a7ee5e17ed60feaafeaa5582a4f46d9317c1b412/programs/token-metadata/program/src/utils/token.rs#L145-L202"><code>metaplex-token-metadata</code> program</a>:</p>
<pre><code class="language-rust">pub(crate) fn validate_mint(
    mint: &amp;AccountInfo,
    metadata: &amp;AccountInfo,
    token_standard: TokenStandard,
) -&gt; Result&lt;Mint, ProgramError&gt; {
let mint_data = &amp;mint.data.borrow();
    let mint = StateWithExtensions::&lt;Mint&gt;::unpack(mint_data)?;

    if !mint.base.is_initialized() {
        return Err(MetadataError::Uninitialized.into());
    }

    if matches!(
        token_standard,
        TokenStandard::NonFungible | TokenStandard::ProgrammableNonFungible
    ) {
        // validates the mint extensions
        mint.get_extension_types()?
            .iter()
            .try_for_each(|extension_type| {
                if !NON_FUNGIBLE_MINT_EXTENSIONS.contains(extension_type) {
                    msg!("Invalid mint extension: {:?}", extension_type);
                    return Err(MetadataError::InvalidMintExtensionType);
                }
                Ok(())
            })?;
    }

    // For all token standards:
    //
    // 1) if the mint close authority extension is enabled, it must
    //    be set to be the metadata account; and
    if let Ok(extension) = mint.get_extension::&lt;MintCloseAuthority&gt;() {
        let close_authority: Option&lt;Pubkey&gt; = extension.close_authority.into();
        if close_authority.is_none() || close_authority != Some(*metadata.key) {
            return Err(MetadataError::InvalidMintCloseAuthority.into());
        }
    }

    // 2) if the metadata pointer extension is enabled, it must be set
    //    to the metadata account address
    if let Ok(extension) = mint.get_extension::&lt;MetadataPointer&gt;() {
        let authority: Option&lt;Pubkey&gt; = extension.authority.into();
        let metadata_address: Option&lt;Pubkey&gt; = extension.metadata_address.into();

        if authority.is_some() {
            msg!("Metadata pointer extension: authority must be None");
            return Err(MetadataError::InvalidMetadataPointer.into());
        }

        if metadata_address != Some(*metadata.key) {
            msg!("Metadata pointer extension: metadata address mismatch");
            return Err(MetadataError::InvalidMetadataPointer.into());
        }
    }

    Ok(mint.base)
}</code></pre>
<p>In addition to the <code>msg!</code> macro providing string logging with formatting, the <code>solana::log</code> module provides a number of other options:</p>
<pre><code class="language-rust">fn process_log(accounts: &amp;[AccountInfo]) -&gt; ProgramResult {
    log::sol_log("just a regular string");
    log::sol_log_64(1, 2, 3, 4, 5);
    log::sol_log_compute_units();
    log::sol_log_data(&amp;[b"some", b"serialized", b"structures", b"as base64"]);
    log::sol_log_params(accounts, &amp;[]);
    log::sol_log_slice(b"some bytes as hex");
    Ok(())
}</code></pre>
<p>The program log from executing the above instruction handler is:</p>
<pre><code># sol_log:
Program log: just a regular string

# sol_log_u64:
Program log: 0x1, 0x2, 0x3, 0x4, 0x5

# sol_log_compute_units:
Program consumption: 1399140 units remaining

# sol_log_data:
Program data: c29tZQ== c2VyaWFsaXplZA== c3RydWN0dXJlcw== YXMgYmFzZTY0

# sol_log_params:
Program log: AccountInfo
Program log: 0x0, 0x0, 0x0, 0x0, 0x0
Program log: - Is signer
Program log: 0x0, 0x0, 0x0, 0x0, 0x1
Program log: - Key
Program log: 11157t3sqMV725NVRLrVQbAu98Jjfk1uCKehJnXXQs
Program log: - Lamports
Program log: 0x0, 0x0, 0x0, 0x0, 0x5f5e100
Program log: - Account data length
Program log: 0x0, 0x0, 0x0, 0x0, 0x0
Program log: - Owner
Program log: 11111111111111111111111111111111
Program log: AccountInfo
Program log: 0x0, 0x0, 0x0, 0x0, 0x1
Program log: - Is signer
Program log: 0x0, 0x0, 0x0, 0x0, 0x0
Program log: - Key
Program log: 11111111111111111111111111111111
Program log: - Lamports
Program log: 0x0, 0x0, 0x0, 0x0, 0xf14a0
Program log: - Account data length
Program log: 0x0, 0x0, 0x0, 0x0, 0xe
Program log: - Owner
Program log: NativeLoader1111111111111111111111111111111
Program log: Instruction data
Program log: 0x0, 0x0, 0x0, 0x0, 0x69
Program log: 0x0, 0x0, 0x0, 0x1, 0x6e
Program log: 0x0, 0x0, 0x0, 0x2, 0x73
Program log: 0x0, 0x0, 0x0, 0x3, 0x74
Program log: 0x0, 0x0, 0x0, 0x4, 0x72
Program log: 0x0, 0x0, 0x0, 0x5, 0x75
Program log: 0x0, 0x0, 0x0, 0x6, 0x63
Program log: 0x0, 0x0, 0x0, 0x7, 0x74
Program log: 0x0, 0x0, 0x0, 0x8, 0x69
Program log: 0x0, 0x0, 0x0, 0x9, 0x6f
Program log: 0x0, 0x0, 0x0, 0xa, 0x6e
Program log: 0x0, 0x0, 0x0, 0xb, 0x20
Program log: 0x0, 0x0, 0x0, 0xc, 0x64
Program log: 0x0, 0x0, 0x0, 0xd, 0x61
Program log: 0x0, 0x0, 0x0, 0xe, 0x74
Program log: 0x0, 0x0, 0x0, 0xf, 0x61

# sol_log_slice:
Program log: 0x0, 0x0, 0x0, 0x0, 0x73
Program log: 0x0, 0x0, 0x0, 0x1, 0x6f
Program log: 0x0, 0x0, 0x0, 0x2, 0x6d
Program log: 0x0, 0x0, 0x0, 0x3, 0x65
Program log: 0x0, 0x0, 0x0, 0x4, 0x20
Program log: 0x0, 0x0, 0x0, 0x5, 0x62
Program log: 0x0, 0x0, 0x0, 0x6, 0x79
Program log: 0x0, 0x0, 0x0, 0x7, 0x74
Program log: 0x0, 0x0, 0x0, 0x8, 0x65
Program log: 0x0, 0x0, 0x0, 0x9, 0x73
Program log: 0x0, 0x0, 0x0, 0xa, 0x20
Program log: 0x0, 0x0, 0x0, 0xb, 0x61
Program log: 0x0, 0x0, 0x0, 0xc, 0x73
Program log: 0x0, 0x0, 0x0, 0xd, 0x20
Program log: 0x0, 0x0, 0x0, 0xe, 0x68
Program log: 0x0, 0x0, 0x0, 0xf, 0x65
Program log: 0x0, 0x0, 0x0, 0x10, 0x78
</code></pre>
<p>In addition to the logging facilities provided by <code>solana_program::log</code>, Anchor provides macros to reduce the boilerplate in emitting structured events via the underlying <code>sol_log_data</code> function:</p>
<pre><code class="language-rust">#[event]
pub struct TaggedEvent {
    you_are_it: Pubkey,
}

#[program]
pub mod errors_events {
    use super::*;

    // ...

    pub fn emit_event(ctx: Context&lt;EmitEvent&gt;) -&gt; Result&lt;()&gt; {
        emit!(TaggedEvent {
            you_are_it: *ctx.accounts.signer.key
        });

        Ok(())
    }
}

#[derive(Accounts)]
pub struct EmitEvent&lt;'info&gt; {
    #[account(mut)]
    pub signer: Signer&lt;'info&gt;,
    pub system_program: Program&lt;'info, System&gt;,
}</code></pre>
<p>Executing the <code>EmitEvent</code> instruction results in the following program log:</p>
<pre><code>Program JEKNVnkbo3jma5nREBBJCDoXFVeKkD56V3xKrvRmWxFG invoke [1]
Program log: Instruction: EmitEvent
Program data: hwVrfRWeHl0AAAABkHB7w+8lvcmO11y3DWHIsQbcJI2O9h4dHbHKQA==
Program JEKNVnkbo3jma5nREBBJCDoXFVeKkD56V3xKrvRmWxFG consumed 1038 of 1400000 compute units
Program JEKNVnkbo3jma5nREBBJCDoXFVeKkD56V3xKrvRmWxFG success
</code></pre>
<p>Note how Anchor automatically inserts the <code>Instruction: EmitEvent</code> log message.</p>
<h3 id="stylus-5"><a class="header" href="#stylus-5">Stylus</a></h3>
<p>For Stylus contracts, emitting structured events is considered best practice whenever contract state changes. Similar to errors, events are defined using the <code>sol!</code> macro and then emitted using the <a href="https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/fn.log.html"><code>log</code></a> function:</p>
<pre><code class="language-rust">sol! {
    event ItChanged(address previous_it, address current_it);
}

#[storage]
#[entrypoint]
pub struct ErrorsEvents {
    it: StorageAddress,
}

#[public]
impl ErrorsEvents {
    /// Tags the caller as "it", emitting an event for the state change
    pub fn tag(&amp;mut self) {
        let msg_sender = self.vm().msg_sender();

        let previous_it = self.it.get();

        self.it.set(msg_sender);

        log(
            self.vm(),
            ItChanged {
                previous_it,
                current_it: msg_sender,
            },
        );
    }
}</code></pre>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<p>With error handling and events covered, you've completed the core migration concepts.</p>
<p>Continue to <a href="./case-study-bonafida-token-vesting.html">Case Study - Migrating Bonafida's Token Vesting to Stylus</a> to see these concepts applied in a complete program migration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="case-study---migrating-bonafidas-token-vesting-to-stylus"><a class="header" href="#case-study---migrating-bonafidas-token-vesting-to-stylus">Case Study - Migrating Bonafida's Token Vesting to Stylus</a></h1>
<p>In this chapter, we will walk through the complete migration of an audited <a href="https://github.com/Bonfida/token-vesting/tree/6234f98229196d1c785dfd2198bb58afc60bca10/program">token vesting program</a>, built by <a href="https://www.bonfida.org/">Bonafida</a> with native Solana, to Arbitrum Stylus. This case study demonstrates the practical application of the concepts we have covered in following chapters:</p>
<ul>
<li><a href="./program-structure.html">Program Structure Migration</a></li>
<li><a href="./state-storage.html">State Storage Patterns</a></li>
<li><a href="./access-control.html">Access Control Migration</a></li>
<li><a href="./fungible-tokens.html">Fungible Token Handling</a></li>
<li><a href="./errors-events.html">Errors and Events</a></li>
</ul>
<p>The program allows any account to setup a token escrow where amounts of a the token will be released to a single destination account according to a pre-defined schedule.</p>
<p>Once the token escrow is established, it cannot be cancelled. Additionally, any account is able to trigger token unlocks.</p>
<h2 id="migration-strategy-1"><a class="header" href="#migration-strategy-1">Migration Strategy</a></h2>
<p>We will migrate the program to Stylus phases:</p>
<ol>
<li><strong>Program Structure</strong>: Convert necessary instructions to <code>#[public]</code> functions.</li>
<li><strong>State Storage</strong>: Assess the data structures stored in accounts and the use of PDAs, then convert to idiomatic Stylus state management.</li>
<li><strong>Business Logic</strong>: Once state and token operations are setup, port the platform-agnostic business logic from instruction handlers to the equivalent functions.</li>
<li><strong>View Functions</strong>: Unlike Solana, view functions need to be added to allow users and clients to easily read the contract storage.</li>
<li><strong>Events</strong>: It is best practice to emit an event when the contract state changes.</li>
<li><strong>Testing</strong>: Ensure feature parity with automated testing.</li>
</ol>
<h2 id="phase-1-program-structure"><a class="header" href="#phase-1-program-structure">Phase 1: Program Structure</a></h2>
<p>The token vesting program defines the following <a href="https://github.com/Bonfida/token-vesting/blob/6234f98229196d1c785dfd2198bb58afc60bca10/program/src/instruction.rs#L61-L115">instructions</a>:</p>
<pre><code class="language-rust">pub enum VestingInstruction {
    /// Initializes an empty program account for the token_vesting program
    ///
    /// Accounts expected by this instruction:
    ///
    ///   * Single owner
    ///   0. `[]` The system program account
    ///   1. `[]` The sysvar Rent account
    ///   1. `[signer]` The fee payer account
    ///   1. `[]` The vesting account
    Init {
        // The seed used to derive the vesting accounts address
        seeds: [u8; 32],
        // The number of release schedules for this contract to hold
        number_of_schedules: u32,
    },

    /// Creates a new vesting schedule contract
    ///
    /// Accounts expected by this instruction:
    ///
    ///   * Single owner
    ///   0. `[]` The spl-token program account
    ///   1. `[writable]` The vesting account
    ///   2. `[writable]` The vesting spl-token account
    ///   3. `[signer]` The source spl-token account owner
    ///   4. `[writable]` The source spl-token account
    Create {
        seeds: [u8; 32],
        mint_address: Pubkey,
        destination_token_address: Pubkey,
        schedules: Vec&lt;Schedule&gt;,
    },

    /// Unlocks a simple vesting contract (SVC) - can only be invoked by the program itself
    /// Accounts expected by this instruction:
    ///
    ///   * Single owner
    ///   0. `[]` The spl-token program account
    ///   1. `[]` The clock sysvar account
    ///   1. `[writable]` The vesting account
    ///   2. `[writable]` The vesting spl-token account
    ///   3. `[writable]` The destination spl-token account
    Unlock { seeds: [u8; 32] },

    /// Change the destination account of a given simple vesting contract (SVC)
    /// - can only be invoked by the present destination address of the contract.
    ///
    /// Accounts expected by this instruction:
    ///
    ///   * Single owner
    ///   0. `[]` The vesting account
    ///   1. `[]` The current destination token account
    ///   2. `[signer]` The destination spl-token account owner
    ///   3. `[]` The new destination spl-token account
    ChangeDestination { seeds: [u8; 32] },
}</code></pre>
<p>We can see that there are three core functions that users of the program can perform:</p>
<ul>
<li><code>Create</code>: sets up the token escrow and specifies the release schedule.</li>
<li><code>Unlock</code>: check the schedule and send any newly unlocked funds to the associated destination.</li>
<li><code>ChangeDestination</code>: the owner of the destination account can elect to change the destination. Note: this also potentially changes the owner.</li>
</ul>
<p>The <code>Init</code> instruction is specific to Solana state management as Stylus contract manage their own state which can grow as required. The <code>seeds</code> parameter for each instruction is used to create a unique identifier for the vesting schedule in the form of a PDA assigned to the vesting schedule state account.</p>
<p>The instructions can be converted to Stylus functions as follows:</p>
<pre><code class="language-rust">#[derive(SolidityError, Debug)]
pub enum ContractError {
    // TODO: declare error variants
}

#[storage]
#[entrypoint]
pub struct TokenVestingContract {
    // TODO: declare storage schema
}

#[public]
impl TokenVestingContract {
    /// Create a vesting schedule for the specified `token` and initial `destination`, returning the schedule identifier.
    ///
    /// # Errors
    /// - TBD
    pub fn create(
        &amp;mut self,
        token: Address,
        owner: Address,
        destination: Address,
        schedule: Vec&lt;(U64, U256)&gt;,
    ) -&gt; Result&lt;U256, ContractError&gt; {
        todo!()
    }

    /// Unlock any vested tokens associated with the `schedule_id`.
    ///
    /// # Errors
    /// - TBD
    pub fn unlock(&amp;mut self, schedule_id: U256) -&gt; Result&lt;(), ContractError&gt; {
        todo!()
    }

    /// Change the `destination` associated with the `schedule_id`, this can only be called by the associated `owner`.
    ///
    /// # Errors
    /// - TBD
    pub fn change_destination(
        &amp;mut self,
        schedule_id: U256,
        destination: Address,
    ) -&gt; Result&lt;(), ContractError&gt; {
        todo!()
    }

    /// Change the `owner` associated with the `schedule_id`, this can only be called by the current `owner`.
    ///
    /// # Errors
    /// - TBD
    pub fn change_owner(&amp;mut self, schedule_id: U256, owner: Address) -&gt; Result&lt;(), ContractError&gt; {
        todo!()
    }
}</code></pre>
<h2 id="phase-2-state-storage"><a class="header" href="#phase-2-state-storage">Phase 2: State Storage</a></h2>
<p>Aside from the escrowed token balance which is stored in the associated token account, the vesting schedule state is represented in the following form:</p>
<pre><code class="language-rust">pub struct VestingSchedule {
    pub release_time: u64,
    pub amount: u64,
}

pub struct VestingScheduleHeader {
    pub destination_address: Pubkey,
    pub mint_address: Pubkey,
    pub is_initialized: bool,
}</code></pre>
<p>The PDA derived from the <code>seeds</code> is associated with a data account arranged in the following <a href="https://github.com/Bonfida/token-vesting/blob/6234f98229196d1c785dfd2198bb58afc60bca10/program/src/state.rs#L23-L110">packed format</a> where <code>N</code> is set in the <code>Init</code> instruction:</p>
<pre><code>[Header: 65 bytes] [Schedule 0: 16 bytes] [Schedule 1: 16 bytes] ... [Schedule N: 16 bytes]

Header (65 bytes):
[0..32] destination_address | [32..64] mint_address | [64] is_initialized

Schedule (16 bytes each):
[0..8] release_time (u64 LE) | [8..16] amount (u64 LE)
</code></pre>
<p>When porting this state management to Stylus, it is idiomatic to store each element in a <code>StorageMap</code> using the schedule identifier as the key:</p>
<pre><code class="language-rust">#[storage]
pub struct Schedule {
    /// Timestamp after which tokens are unlocked
    timestamp: StorageU64,
    /// Amount of tokens unlocked (set to zero afterwards)
    amount: StorageU256,
}

#[storage]
#[entrypoint]
pub struct TokenVestingContract {
    /// Incremented to determine the schedule identifier
    schedule_count: StorageU256,
    /// Token vested by the schedule
    token: StorageMap&lt;U256, StorageAddress&gt;,
    /// Owner and benefactor of the schedule
    owner: StorageMap&lt;U256, StorageAddress&gt;,
    /// Destination address for unlocked tokens
    destination: StorageMap&lt;U256, StorageAddress&gt;,
    /// Scheduled token unlocks
    schedule: StorageMap&lt;U256, StorageVec&lt;Schedule&gt;&gt;,
}</code></pre>
<h2 id="phase-3-business-logic"><a class="header" href="#phase-3-business-logic">Phase 3: Business Logic</a></h2>
<h3 id="create-token-vesting-schedule"><a class="header" href="#create-token-vesting-schedule">Create token vesting schedule</a></h3>
<p>The <a href="https://github.com/Bonfida/token-vesting/blob/6234f98229196d1c785dfd2198bb58afc60bca10/program/src/processor.rs#L72-L183"><code>Create</code> instruction handler</a> from the native Solana program is as follows:</p>
<pre><code class="language-rust">pub fn process_create(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    seeds: [u8; 32],
    mint_address: &amp;Pubkey,
    destination_token_address: &amp;Pubkey,
    schedules: Vec&lt;Schedule&gt;,
) -&gt; ProgramResult {
    let accounts_iter = &amp;mut accounts.iter();

    let spl_token_account = next_account_info(accounts_iter)?;
    let vesting_account = next_account_info(accounts_iter)?;
    let vesting_token_account = next_account_info(accounts_iter)?;
    let source_token_account_owner = next_account_info(accounts_iter)?;
    let source_token_account = next_account_info(accounts_iter)?;

    let vesting_account_key = Pubkey::create_program_address(&amp;[&amp;seeds], program_id)?;
    if vesting_account_key != *vesting_account.key {
        msg!("Provided vesting account is invalid");
        return Err(ProgramError::InvalidArgument);
    }

    if !source_token_account_owner.is_signer {
        msg!("Source token account owner should be a signer.");
        return Err(ProgramError::InvalidArgument);
    }

    if *vesting_account.owner != *program_id {
        msg!("Program should own vesting account");
        return Err(ProgramError::InvalidArgument);
    }

    // Verifying that no SVC was already created with this seed
    let is_initialized =
        vesting_account.try_borrow_data()?[VestingScheduleHeader::LEN - 1] == 1;

    if is_initialized {
        msg!("Cannot overwrite an existing vesting contract.");
        return Err(ProgramError::InvalidArgument);
    }

    let vesting_token_account_data = Account::unpack(&amp;vesting_token_account.data.borrow())?;

    if vesting_token_account_data.owner != vesting_account_key {
        msg!("The vesting token account should be owned by the vesting account.");
        return Err(ProgramError::InvalidArgument);
    }

    if vesting_token_account_data.delegate.is_some() {
        msg!("The vesting token account should not have a delegate authority");
        return Err(ProgramError::InvalidAccountData);
    }

    if vesting_token_account_data.close_authority.is_some() {
        msg!("The vesting token account should not have a close authority");
        return Err(ProgramError::InvalidAccountData);
    }

    let state_header = VestingScheduleHeader {
        destination_address: *destination_token_address,
        mint_address: *mint_address,
        is_initialized: true,
    };

    let mut data = vesting_account.data.borrow_mut();
    if data.len() != VestingScheduleHeader::LEN + schedules.len() * VestingSchedule::LEN {
        return Err(ProgramError::InvalidAccountData)
    }
    state_header.pack_into_slice(&amp;mut data);

    let mut offset = VestingScheduleHeader::LEN;
    let mut total_amount: u64 = 0;

    for s in schedules.iter() {
        let state_schedule = VestingSchedule {
            release_time: s.release_time,
            amount: s.amount,
        };
        state_schedule.pack_into_slice(&amp;mut data[offset..]);
        let delta = total_amount.checked_add(s.amount);
        match delta {
            Some(n) =&gt; total_amount = n,
            None =&gt; return Err(ProgramError::InvalidInstructionData), // Total amount overflows u64
        }
        offset += SCHEDULE_SIZE;
    }
    
    if Account::unpack(&amp;source_token_account.data.borrow())?.amount &lt; total_amount {
        msg!("The source token account has insufficient funds.");
        return Err(ProgramError::InsufficientFunds)
    };

    let transfer_tokens_to_vesting_account = transfer(
        spl_token_account.key,
        source_token_account.key,
        vesting_token_account.key,
        source_token_account_owner.key,
        &amp;[],
        total_amount,
    )?;

    invoke(
        &amp;transfer_tokens_to_vesting_account,
        &amp;[
            source_token_account.clone(),
            vesting_token_account.clone(),
            spl_token_account.clone(),
            source_token_account_owner.clone(),
        ],
    )?;
    Ok(())
}</code></pre>
<p>This can be boiled down the following steps:</p>
<ol>
<li>Validate inputs such as token and destination accounts.</li>
<li>Compute total amount to be held in escrow, return an error if the schedule is empty.</li>
<li>Write schedule state to storage.</li>
<li>Transfer the computed total token amount to the escrow account, reverting on transfer failure.</li>
</ol>
<pre><code class="language-rust">sol! {
    #[derive(Debug)]
    error InvalidToken();
    #[derive(Debug)]
    error InvalidDestination();
    #[derive(Debug)]
    error InvalidSchedule();
    #[derive(Debug)]
    error TokenDepositTransferFailed();
}

#[derive(SolidityError, Debug)]
pub enum ContractError {
    InvalidToken(InvalidToken),
    InvalidDestination(InvalidDestination),
    InvalidSchedule(InvalidSchedule),
    TokenDepositFailed(TokenDepositTransferFailed),
}

#[public]
impl TokenVestingContract {
    /// Create a vesting schedule for the specified `token` and initial `destination`, returning the schedule identifier.
    /// Attempts to transfer the total amount of tokens scheduled from the sender to this contract.
    ///
    /// Note: setting a zero address for `owner` means the `destination` is immutable.
    ///
    /// # Errors
    /// - InvalidToken: if the provided token address is zero
    /// - InvalidDestination: if the provided destination address is zero
    /// - InvalidSchedule: if the provided schedule is empty, contains a zero amount, is not ordered chronologically or the total amount overflows 256 bits.
    /// - TokenDepositTransferFailed: if there is an error transferring the total vesting amount from the sender to the contract
    pub fn create(
        &amp;mut self,
        token: Address,
        owner: Address,
        destination: Address,
        schedule: Vec&lt;(u64, U256)&gt;,
    ) -&gt; Result&lt;U256, ContractError&gt; {
        if token == Address::ZERO {
            return Err(InvalidToken {}.into());
        }

        if destination == Address::ZERO {
            return Err(InvalidDestination {}.into());
        }

        if schedule.is_empty() {
            return Err(InvalidSchedule {}.into());
        }

        let schedule_id = self.schedule_count.get() + U256::ONE;

        let mut schedule_store = self.schedule.setter(schedule_id);
        let mut total_vested_amount = U256::ZERO;
        let mut last_timestamp = 0u64;
        let mut timestamps = Vec::with_capacity(schedule.len());
        let mut amounts = Vec::with_capacity(schedule.len());
        for (timestamp, amount) in schedule {
            if amount.is_zero() || timestamp &lt; last_timestamp {
                return Err(InvalidSchedule {}.into());
            }

            last_timestamp = timestamp;
            total_vested_amount = total_vested_amount
                .checked_add(amount)
                .ok_or(InvalidSchedule {})?;

            timestamps.push(timestamp);
            amounts.push(amount);

            let mut schedule_item = schedule_store.grow();
            schedule_item.timestamp.set(U64::from(timestamp));
            schedule_item.amount.set(amount);
        }

        self.schedule_count.set(schedule_id);
        self.token.insert(schedule_id, token);
        self.owner.insert(schedule_id, owner);
        self.destination.insert(schedule_id, destination);

        let contract_addr = self.vm().contract_address();
        let sender = self.vm().msg_sender();
        Erc20Interface::new(token)
            .transfer_from(self, sender, contract_addr, total_vested_amount)
            .map_err(|_| TokenDepositTransferFailed {})?;

        Ok(schedule_id)
    }


    // ...
}</code></pre>
<h3 id="unlock-tokens"><a class="header" href="#unlock-tokens">Unlock tokens</a></h3>
<p>The <a href="https://github.com/Bonfida/token-vesting/blob/6234f98229196d1c785dfd2198bb58afc60bca10/program/src/processor.rs#L185-L268"><code>Unlock</code> instruction handler</a> is implemented as follows:</p>
<pre><code class="language-rust">pub fn process_unlock(
    program_id: &amp;Pubkey,
    _accounts: &amp;[AccountInfo],
    seeds: [u8; 32],
) -&gt; ProgramResult {
    let accounts_iter = &amp;mut _accounts.iter();

    let spl_token_account = next_account_info(accounts_iter)?;
    let clock_sysvar_account = next_account_info(accounts_iter)?;
    let vesting_account = next_account_info(accounts_iter)?;
    let vesting_token_account = next_account_info(accounts_iter)?;
    let destination_token_account = next_account_info(accounts_iter)?;

    let vesting_account_key = Pubkey::create_program_address(&amp;[&amp;seeds], program_id)?;
    if vesting_account_key != *vesting_account.key {
        msg!("Invalid vesting account key");
        return Err(ProgramError::InvalidArgument);
    }

    if spl_token_account.key != &amp;spl_token::id() {
        msg!("The provided spl token program account is invalid");
        return Err(ProgramError::InvalidArgument)
    }

    let packed_state = &amp;vesting_account.data;
    let header_state =
        VestingScheduleHeader::unpack(&amp;packed_state.borrow()[..VestingScheduleHeader::LEN])?;

    if header_state.destination_address != *destination_token_account.key {
        msg!("Contract destination account does not matched provided account");
        return Err(ProgramError::InvalidArgument);
    }

    let vesting_token_account_data = Account::unpack(&amp;vesting_token_account.data.borrow())?;

    if vesting_token_account_data.owner != vesting_account_key {
        msg!("The vesting token account should be owned by the vesting account.");
        return Err(ProgramError::InvalidArgument);
    }

    // Unlock the schedules that have reached maturity
    let clock = Clock::from_account_info(&amp;clock_sysvar_account)?;
    let mut total_amount_to_transfer = 0;
    let mut schedules = unpack_schedules(&amp;packed_state.borrow()[VestingScheduleHeader::LEN..])?;

    for s in schedules.iter_mut() {
        if clock.unix_timestamp as u64 &gt;= s.release_time {
            total_amount_to_transfer += s.amount;
            s.amount = 0;
        }
    }
    if total_amount_to_transfer == 0 {
        msg!("Vesting contract has not yet reached release time");
        return Err(ProgramError::InvalidArgument);
    }

    let transfer_tokens_from_vesting_account = transfer(
        &amp;spl_token_account.key,
        &amp;vesting_token_account.key,
        destination_token_account.key,
        &amp;vesting_account_key,
        &amp;[],
        total_amount_to_transfer,
    )?;

    invoke_signed(
        &amp;transfer_tokens_from_vesting_account,
        &amp;[
            spl_token_account.clone(),
            vesting_token_account.clone(),
            destination_token_account.clone(),
            vesting_account.clone(),
        ],
        &amp;[&amp;[&amp;seeds]],
    )?;

    // Reset released amounts to 0. This makes the simple unlock safe with complex scheduling contracts
    pack_schedules_into_slice(
        schedules,
        &amp;mut packed_state.borrow_mut()[VestingScheduleHeader::LEN..],
    );

    Ok(())
}</code></pre>
<p>Looking past the Solana-specific account validation and deserialization logic, the handler needs to do the following:</p>
<ol>
<li>Check that the specified schedule exists.</li>
<li>Iterate over the schedule unlocks, summing the unlocked token amount and zeroing newly unlocked tokens.</li>
<li>Check that a non-zero amount of tokens needs to be transferred to the destination.</li>
<li>Transfer the unlocked amount from the escrow account to the current destination account.</li>
</ol>
<p>Additionally, the handler needs to take care that a user is not locked out of claiming their tokens due to gas exhaustion when looping over the schedule.
Pagination parameters should be added to allow the caller to limit the iterations.</p>
<p>Invariant: The escrow account <strong>MUST</strong> have enough tokens to complete the transfer.</p>
<p>Implemented in Stylus, it can look like this:</p>
<pre><code class="language-rust">sol! {
    // ...
    #[derive(Debug)]
    error ScheduleNotFound();
    #[derive(Debug)]
    error NoUnlocksAvailable();
}

#[derive(SolidityError, Debug)]
pub enum ContractError {
    // ...
    ScheduleNotFound(ScheduleNotFound),
    NoUnlocksAvailable(NoUnlocksAvailable),
}

#[public]
impl TokenVestingContract {
    // ...

    /// Unlock any vested tokens in tranches `start_idx` up to and including `end_idx` associated with the `schedule_id` and transfers them to the set `destination`
    ///
    /// # Errors
    /// - ScheduleNotFound: if the provided `schedule_id` is not associated with a schedule
    /// - NoUnlocksAvailable: if there a zero unlocked tokens to transfer
    pub fn unlock(
        &amp;mut self,
        schedule_id: U256,
        start_idx: u32,
        end_idx: u32,
    ) -&gt; Result&lt;(), ContractError&gt; {
        // Step 1: Check that the schedule exits
        let token = self.token.get(schedule_id);

        if token.is_zero() {
            return Err(ScheduleNotFound {}.into());
        }

        // Step 2: Determine unlocked token amount &amp; zero newly unlocked amounts, respecting the iteration limits
        let now = U64::from(self.vm().block_timestamp());

        let mut schedule = self.schedule.setter(schedule_id);
        let mut idx = start_idx;
        let mut unlocked_token_amount = U256::ZERO;
        while idx &lt;= end_idx {
            let Some(mut schedule_item) = schedule.setter(idx) else {
                break;
            };

            idx += 1;

            if schedule_item.timestamp.get() &gt; now {
                break;
            }

            let amount = schedule_item.amount.get();

            if amount.is_zero() {
                continue;
            }

            schedule_item.amount.set(U256::ZERO);

            // Overflow not possible because: escrow total &lt;= U256::MAX checked during creation
            unlocked_token_amount += amount;
        }

        // Step 3: Check that unlocks are available
        if unlocked_token_amount.is_zero() {
            return Err(NoUnlocksAvailable {}.into());
        }

        let destination = self.destination.get(schedule_id);

        log(
            self.vm(),
            TokensUnlocked {
                schedule_id,
                destination,
                unlocked_token_amount,
            },
        );

        // Step 4: Transfer the unlocked amount to the current destination account
        Erc20Interface::new(token)
            .transfer(self, destination, unlocked_token_amount)
            .expect("Invariant: the contract always has sufficient balance to satisfy unlocks");

        Ok(())
    }

    // ...
}</code></pre>
<h3 id="change-destination"><a class="header" href="#change-destination">Change destination</a></h3>
<p>The <a href="https://github.com/Bonfida/token-vesting/blob/6234f98229196d1c785dfd2198bb58afc60bca10/program/src/processor.rs#L270-L318"><code>ChangeDestination</code> instruction handler</a> looks like:</p>
<pre><code class="language-rust">pub fn process_change_destination(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    seeds: [u8; 32],
) -&gt; ProgramResult {
    let accounts_iter = &amp;mut accounts.iter();

    let vesting_account = next_account_info(accounts_iter)?;
    let destination_token_account = next_account_info(accounts_iter)?;
    let destination_token_account_owner = next_account_info(accounts_iter)?;
    let new_destination_token_account = next_account_info(accounts_iter)?;

    if vesting_account.data.borrow().len() &lt; VestingScheduleHeader::LEN {
        return Err(ProgramError::InvalidAccountData)
    }
    let vesting_account_key = Pubkey::create_program_address(&amp;[&amp;seeds], program_id)?;
    let state = VestingScheduleHeader::unpack(
        &amp;vesting_account.data.borrow()[..VestingScheduleHeader::LEN],
    )?;

    if vesting_account_key != *vesting_account.key {
        msg!("Invalid vesting account key");
        return Err(ProgramError::InvalidArgument);
    }

    if state.destination_address != *destination_token_account.key {
        msg!("Contract destination account does not matched provided account");
        return Err(ProgramError::InvalidArgument);
    }

    if !destination_token_account_owner.is_signer {
        msg!("Destination token account owner should be a signer.");
        return Err(ProgramError::InvalidArgument);
    }

    let destination_token_account = Account::unpack(&amp;destination_token_account.data.borrow())?;

    if destination_token_account.owner != *destination_token_account_owner.key {
        msg!("The current destination token account isn't owned by the provided owner");
        return Err(ProgramError::InvalidArgument);
    }

    let mut new_state = state;
    new_state.destination_address = *new_destination_token_account.key;
    new_state
        .pack_into_slice(&amp;mut vesting_account.data.borrow_mut()[..VestingScheduleHeader::LEN]);

    Ok(())
}</code></pre>
<p>This boils down to:</p>
<ol>
<li>Check the proposed destination is valid</li>
<li>Check the schedule exits</li>
<li>Check the caller is the owner</li>
<li>Overwrite the existing destination</li>
</ol>
<p>As mentioned in Phase 1, as the owner is determined by checking the owner of the destination associated token account, the <code>ChangeDestination</code> instruction also potentially changes the owner. In order to have feature parity, a separate <code>change_owner</code> function is added to the Stylus implementation.</p>
<pre><code class="language-rust">#[public]
impl TokenVestingContract {
    // ...

    /// Change the `destination` associated with the `schedule_id`, this can only be called by the associated `owner`.
    ///
    /// # Errors
    /// - ScheduleNotFound: if the provided `schedule_id` is not associated with a schedule
    /// - InvalidDestination: if the provided destination address is zero
    /// - Unauthorized: if the caller is not the owner of the schedule
    pub fn change_destination(
        &amp;mut self,
        schedule_id: U256,
        destination: Address,
    ) -&gt; Result&lt;(), ContractError&gt; {
        // Step 1: Check that the proposed destination is valid
        if destination == Address::ZERO {
            return Err(InvalidDestination {}.into());
        }

        // Step 2: Check that the schedule exists
        if self.token.get(schedule_id).is_zero() {
            return Err(ScheduleNotFound {}.into());
        }

        // Step 3: Check that the caller is the current owner
        if self.vm().msg_sender() != self.owner.get(schedule_id) {
            return Err(Unauthorized {}.into());
        }

        // Step 4: Overwrite the stored destination
        self.destination.insert(schedule_id, destination);

        Ok(())
    }

    /// Change the `owner` associated with the `schedule_id`, this can only be called by the current `owner`.
    ///
    /// Note: setting a zero address for `owner` means the `destination` is now immutable.
    ///
    /// # Errors
    /// - ScheduleNotFound: if the provided `schedule_id` is not associated with a schedule
    /// - Unauthorized: if the caller is not the owner of the schedule
    pub fn change_owner(&amp;mut self, schedule_id: U256, owner: Address) -&gt; Result&lt;(), ContractError&gt; {
        // Step 1: Check that the schedule exists
        if self.token.get(schedule_id).is_zero() {
            return Err(ScheduleNotFound {}.into());
        }

        // Step 2: Check that the caller is the current owner
        if self.vm().msg_sender() != self.owner.get(schedule_id) {
            return Err(Unauthorized {}.into());
        }

        // Step 3: Overwrite the stored owner
        self.owner.insert(schedule_id, owner);

        Ok(())
    }

    // ...
}</code></pre>
<h2 id="phase-4-view-functions"><a class="header" href="#phase-4-view-functions">Phase 4: View Functions</a></h2>
<p>It is conventional to add state accessor functions to Stylus contracts:</p>
<pre><code class="language-rust">#[public]
impl TokenVestingContract {
    // ...
    
    // View functions
    fn schedule_count(&amp;self) -&gt; U256 {
        self.schedule_count.get()
    }

    fn token(&amp;self, schedule_id: U256) -&gt; Address {
        self.token.get(schedule_id)
    }

    fn destination(&amp;self, schedule_id: U256) -&gt; Address {
        self.destination.get(schedule_id)
    }

    fn owner(&amp;self, schedule_id: U256) -&gt; Address {
        self.owner.get(schedule_id)
    }

    fn schedule(&amp;self, schedule_id: U256) -&gt; Vec&lt;(U64, U256)&gt; {
        if self.token(schedule_id).is_zero() {
            return vec![];
        }

        let schedule_store = self.schedule.getter(schedule_id);

        let mut schedule = vec![];
        let mut idx = 0;
        while let Some(schedule_item) = schedule_store.getter(idx) {
            schedule.push((schedule_item.timestamp.get(), schedule_item.amount.get()));
            idx += 1;
        }

        schedule
    }
}</code></pre>
<h2 id="phase-5-events"><a class="header" href="#phase-5-events">Phase 5: Events</a></h2>
<p>To allow efficient auditing and state tracking for clients, it is best practice to emit a structured event whenever the contract state is updated:</p>
<pre><code class="language-rust">sol! {
    // ...

    event ScheduleCreated(
        uint256 schedule_id,
        address token,
        address owner,
        address destination,
        uint64[] timestamps,
        uint256[] amounts
    );

    event TokensUnlocked(
        uint256 schedule_id,
        address destination,
        uint256 unlocked_token_amount,
    );

    event DestinationChanged(
        uint256 schedule_id,
        address old_destination,
        address new_destination,
    );

    event OwnerChanged(
        uint256 schedule_id,
        address old_owner,
        address new_owner,
    );
}


#[public]
impl TokenVestingContract {
    // ...

    pub fn create(
        &amp;mut self,
        token: Address,
        owner: Address,
        destination: Address,
        schedule: Vec&lt;(u64, U256)&gt;,
    ) -&gt; Result&lt;U256, ContractError&gt; {
        if token == Address::ZERO {
            return Err(InvalidToken {}.into());
        }

        if source == Address::ZERO {
            return Err(InvalidSource {}.into());
        }

        if destination == Address::ZERO {
            return Err(InvalidDestination {}.into());
        }

        if schedule.is_empty() {
            return Err(InvalidSchedule {}.into());
        }

        let schedule_id = self.schedule_count.get() + U256::ONE;

        let mut schedule_store = self.schedule.setter(schedule_id);
        let mut total_vested_amount = U256::ZERO;
        let mut last_timestamp = 0u64;
        let mut timestamps = Vec::with_capacity(schedule.len());
        let mut amounts = Vec::with_capacity(schedule.len());
        for (timestamp, amount) in schedule {
            if amount.is_zero() || timestamp &lt;= last_timestamp {
                return Err(InvalidSchedule {}.into());
            }

            last_timestamp = timestamp;
            total_vested_amount = total_vested_amount
                .checked_add(amount)
                .ok_or(InvalidSchedule {})?;

            timestamps.push(timestamp);
            amounts.push(amount);

            let mut schedule_item = schedule_store.grow();
            schedule_item.timestamp.set(U64::from(timestamp));
            schedule_item.amount.set(amount);
        }

        self.schedule_count.set(schedule_id);
        self.token.insert(schedule_id, token);
        self.owner.insert(schedule_id, owner);
        self.destination.insert(schedule_id, destination);

        log(
            self.vm(),
            ScheduleCreated {
                schedule_id,
                token,
                owner,
                destination,
                timestamps,
                amounts,
            },
        );

        let contract_addr = self.vm().contract_address();
        Erc20Interface::new(token)
            .transfer_from(self, source, contract_addr, total_vested_amount)
            .map_err(|_| TokenDepositTransferFailed {})?;

        Ok(schedule_id)
    }

    pub fn unlock(&amp;mut self, schedule_id: U256) -&gt; Result&lt;(), ContractError&gt; {
        let token = self.token.get(schedule_id);

        if token.is_zero() {
            return Err(ScheduleNotFound {}.into());
        }

        let now = U64::from(self.vm().block_timestamp());

        let mut schedule = self.schedule.setter(schedule_id);
        let mut idx = 0;
        let mut unlocked_token_amount = U256::ZERO;
        loop {
            let Some(mut schedule_item) = schedule.setter(idx) else {
                break;
            };

            idx += 1;

            if schedule_item.timestamp.get() &gt; now {
                break;
            }

            let amount = schedule_item.amount.get();

            if amount.is_zero() {
                continue;
            }

            schedule_item.amount.set(U256::ZERO);

            // Overflow not possible because: escrow total &lt;= U256::MAX checked during creation
            unlocked_token_amount += amount;
        }

        if unlocked_token_amount.is_zero() {
            return Err(NoUnlocksAvailable {}.into());
        }

        let destination = self.destination.get(schedule_id);

        log(
            self.vm(),
            TokensUnlocked {
                schedule_id,
                destination,
                unlocked_token_amount,
            },
        );

        Erc20Interface::new(token)
            .transfer(self, destination, unlocked_token_amount)
            .expect("Invariant: the contract always has sufficient balance to satisfy unlocks");

        Ok(())
    }

    pub fn change_destination(
        &amp;mut self,
        schedule_id: U256,
        new_destination: Address,
    ) -&gt; Result&lt;(), ContractError&gt; {
        if new_destination == Address::ZERO {
            return Err(InvalidDestination {}.into());
        }

        if self.token.get(schedule_id).is_zero() {
            return Err(ScheduleNotFound {}.into());
        }

        if self.vm().msg_sender() != self.owner.get(schedule_id) {
            return Err(Unauthorized {}.into());
        }

        let old_destination = self.destination.replace(schedule_id, new_destination);

        log(
            self.vm(),
            DestinationChanged {
                schedule_id,
                old_destination,
                new_destination,
            },
        );

        Ok(())
    }

    pub fn change_owner(
        &amp;mut self,
        schedule_id: U256,
        new_owner: Address,
    ) -&gt; Result&lt;(), ContractError&gt; {
        if self.token.get(schedule_id).is_zero() {
            return Err(ScheduleNotFound {}.into());
        }

        if self.vm().msg_sender() != self.owner.get(schedule_id) {
            return Err(Unauthorized {}.into());
        }

        let old_owner = self.owner.replace(schedule_id, new_owner);

        log(
            self.vm(),
            OwnerChanged {
                schedule_id,
                old_owner,
                new_owner,
            },
        );

        Ok(())
    }
    // ...
}</code></pre>
<h2 id="phase-6-testing"><a class="header" href="#phase-6-testing">Phase 6: Testing</a></h2>
<p>Bonafida's Token Vesting repository has a <a href="https://github.com/Bonfida/token-vesting/blob/6234f98229196d1c785dfd2198bb58afc60bca10/program/tests/functional.rs">single functional test</a> and a series of <a href="https://github.com/Bonfida/token-vesting/blob/6234f98229196d1c785dfd2198bb58afc60bca10/program/fuzz/src/vesting_fuzz.rs">fuzzing tests</a>. As fuzzing is beyond the scope of this case study, we will focus on achieving functional unit testing parity.</p>
<h2 id="core-operations-tested"><a class="header" href="#core-operations-tested">Core Operations Tested</a></h2>
<h3 id="1-vesting-schedule-creation"><a class="header" href="#1-vesting-schedule-creation">1. Vesting Schedule Creation</a></h3>
<pre><code class="language-rust">let schedules = vec![
    Schedule {amount: 20, release_time: 0},
    Schedule {amount: 20, release_time: 2},
    Schedule {amount: 20, release_time: 5}
];

create(
    &amp;program_id,
    &amp;spl_token::id(),
    &amp;vesting_account_key,
    &amp;vesting_token_account.pubkey(),
    &amp;source_account.pubkey(),
    &amp;source_token_account.pubkey(),
    &amp;destination_token_account.pubkey(),
    &amp;mint.pubkey(),
    schedules,
    seeds.clone()
)</code></pre>
<p>Creates a vesting contract that locks 60 tokens total with three release points.</p>
<h3 id="2-token-unlocking"><a class="header" href="#2-token-unlocking">2. Token Unlocking</a></h3>
<pre><code class="language-rust">unlock(
    &amp;program_id,
    &amp;spl_token::id(),
    &amp;sysvar::clock::id(),
    &amp;vesting_account_key,
    &amp;vesting_token_account.pubkey(),
    &amp;destination_token_account.pubkey(),
    seeds.clone()
)</code></pre>
<p>Attempts to unlock vested tokens based on the current time.</p>
<h3 id="3-destination-change"><a class="header" href="#3-destination-change">3. Destination Change</a></h3>
<pre><code class="language-rust">change_destination(
    &amp;program_id,
    &amp;vesting_account_key,
    &amp;destination_account.pubkey(),
    &amp;destination_token_account.pubkey(),
    &amp;new_destination_token_account.pubkey(),
    seeds.clone()
)</code></pre>
<p>Changes where future unlocked tokens will be sent, requiring authorization from the current destination account owner.</p>
<p>Note that the test only ever executes the instructions and checks that no errors are returned. It does not verify that token balances or other account data has been updated correctly.</p>
<p>Using the <a href="https://docs.rs/motsu/latest/motsu/index.html"><code>motsu</code></a> test harness library developed by OpenZeppelin, we can create a series of unit tests that verify the contract business logic and interactions with the provided ERC20 token.</p>
<p>For the first test, verify that creating a schedule works as expected:</p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;

    use alloy_primitives::{Address, U256, U64};
    use motsu::prelude::*;
    use openzeppelin_stylus::token::erc20::{Erc20, IErc20};

    pub const TOTAL_SUPPLY: u64 = 1_000_000;

    fn setup_env(token: &amp;Contract&lt;Erc20&gt;, source: Address) {
        // Environment always starts at timestamp 1 for simplicity
        VM::context().set_block_timestamp(1);

        // Mint total supply of tokens to source account
        token
            .sender(source)
            ._mint(source, U256::from(TOTAL_SUPPLY))
            .motsu_unwrap();
    }

    #[motsu::test]
    fn test_create_vesting_schedule(
        token: Contract&lt;Erc20&gt;,
        vesting: Contract&lt;TokenVestingContract&gt;,
        owner: Address,
        source: Address,
        destination: Address,
    ) {
        setup_env(&amp;token, source);

        // Approve vesting contract to transfer tokens
        let vesting_amount = U256::from(60u64);
        token
            .sender(source)
            .approve(vesting.address(), vesting_amount)
            .motsu_unwrap();

        // Create vesting schedule with 3 unlocks
        let schedule = vec![
            (0u64, U256::from(20u64)),   // Immediate unlock
            (100u64, U256::from(20u64)), // After timestamp 100
            (200u64, U256::from(20u64)), // After timestamp 200
        ];

        let schedule_id = vesting
            .sender(source)
            .create(token.address(), owner, destination, schedule.clone())
            .motsu_unwrap();

        // Verify schedule was created
        assert_eq!(schedule_id, U256::from(1u64));
        assert_eq!(vesting.sender(source).schedule_count(), U256::from(1u64));
        assert_eq!(vesting.sender(source).token(schedule_id), token.address());
        assert_eq!(vesting.sender(source).owner(schedule_id), owner);
        assert_eq!(vesting.sender(source).destination(schedule_id), destination);

        // Verify schedule details
        let stored_schedule = vesting.sender(source).schedule(schedule_id);
        assert_eq!(stored_schedule.len(), 3);
        assert_eq!(stored_schedule[0], (U64::from(0u64), U256::from(20u64)));
        assert_eq!(stored_schedule[1], (U64::from(100u64), U256::from(20u64)));
        assert_eq!(stored_schedule[2], (U64::from(200u64), U256::from(20u64)));

        // Verify tokens were transferred to vesting contract
        assert_eq!(
            token.sender(source).balance_of(vesting.address()),
            vesting_amount
        );
        assert_eq!(
            token.sender(source).balance_of(source),
            U256::from(TOTAL_SUPPLY) - vesting_amount
        );
    }</code></pre>
<p>Next, verify that each tranche can be unlocked:</p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    // ...
    
    #[motsu::test]
    fn test_unlock_tokens(
        token: Contract&lt;Erc20&gt;,
        vesting: Contract&lt;TokenVestingContract&gt;,
        owner: Address,
        source: Address,
        destination: Address,
    ) {
        setup_env(&amp;token, source);

        let vesting_amount = U256::from(60u64);
        token
            .sender(source)
            .approve(vesting.address(), vesting_amount)
            .motsu_unwrap();

        let schedule = vec![
            (0u64, U256::from(20u64)),
            (100u64, U256::from(20u64)),
            (200u64, U256::from(20u64)),
        ];

        let schedule_id = vesting
            .sender(source)
            .create(token.address(), owner, destination, schedule)
            .motsu_unwrap();

        // Test 1: Unlock at timestamp 1 (immediate unlock for first tranche)
        vesting
            .sender(source)
            .unlock(schedule_id, 0, 2)
            .motsu_unwrap();

        assert_eq!(
            token.sender(source).balance_of(destination),
            U256::from(20u64)
        );
        assert_eq!(
            token.sender(source).balance_of(vesting.address()),
            U256::from(40u64)
        );

        // Verify first unlock is now zero in schedule
        let stored_schedule = vesting.sender(source).schedule(schedule_id);
        assert_eq!(stored_schedule[0].1, U256::ZERO);

        // Test 2: Try to unlock again at same timestamp (should fail - no unlocks available)
        let err = vesting
            .sender(source)
            .unlock(schedule_id, 0, 2)
            .motsu_unwrap_err();
        assert!(matches!(err, ContractError::NoUnlocksAvailable(_)));

        // Test 3: Unlock at timestamp 150 (should unlock second tranche)
        VM::context().set_block_timestamp(150);
        vesting
            .sender(source)
            .unlock(schedule_id, 0, 2)
            .motsu_unwrap();

        assert_eq!(
            token.sender(source).balance_of(destination),
            U256::from(40u64)
        );
        assert_eq!(
            token.sender(source).balance_of(vesting.address()),
            U256::from(20u64)
        );

        // Test 4: Unlock at timestamp 250 (should unlock final tranche)
        VM::context().set_block_timestamp(250);
        vesting
            .sender(source)
            .unlock(schedule_id, 0, 2)
            .motsu_unwrap();

        assert_eq!(
            token.sender(source).balance_of(destination),
            U256::from(60u64)
        );
        assert_eq!(
            token.sender(source).balance_of(vesting.address()),
            U256::ZERO
        );

        // All tokens should be unlocked now
        let final_schedule = vesting.sender(source).schedule(schedule_id);
        assert!(final_schedule.iter().all(|(_, amount)| amount.is_zero()));
    }

    #[motsu::test]
    fn test_unlock_multiple_at_once(
        token: Contract&lt;Erc20&gt;,
        vesting: Contract&lt;TokenVestingContract&gt;,
        owner: Address,
        source: Address,
        destination: Address,
    ) {
        setup_env(&amp;token, source);

        let vesting_amount = U256::from(60u64);
        token
            .sender(source)
            .approve(vesting.address(), vesting_amount)
            .motsu_unwrap();

        let schedule = vec![
            (50u64, U256::from(20u64)),
            (100u64, U256::from(20u64)),
            (150u64, U256::from(20u64)),
        ];

        let schedule_id = vesting
            .sender(source)
            .create(token.address(), owner, destination, schedule)
            .motsu_unwrap();

        // Jump to timestamp 120 - should unlock first two tranches at once
        VM::context().set_block_timestamp(120);
        vesting
            .sender(source)
            .unlock(schedule_id, 0, 2)
            .motsu_unwrap();

        assert_eq!(
            token.sender(source).balance_of(destination),
            U256::from(40u64)
        );
        assert_eq!(
            token.sender(source).balance_of(vesting.address()),
            U256::from(20u64)
        );
    }

    #[motsu::test]
    fn test_unlock_multiple_out_of_order(
        token: Contract&lt;Erc20&gt;,
        vesting: Contract&lt;TokenVestingContract&gt;,
        owner: Address,
        source: Address,
        destination: Address,
    ) {
        setup_env(&amp;token, source);

        let vesting_amount = U256::from(80u64);
        token
            .sender(source)
            .approve(vesting.address(), vesting_amount)
            .motsu_unwrap();

        let schedule = vec![
            (50u64, U256::from(20u64)),
            (100u64, U256::from(20u64)),
            (150u64, U256::from(20u64)),
            (200u64, U256::from(20u64)),
        ];

        let schedule_id = vesting
            .sender(source)
            .create(token.address(), owner, destination, schedule)
            .motsu_unwrap();

        // Jump to timestamp 250 - all tranches unlocked
        VM::context().set_block_timestamp(250);

        // unlock middle tranches
        vesting
            .sender(source)
            .unlock(schedule_id, 1, 2)
            .motsu_unwrap();

        assert_eq!(
            token.sender(source).balance_of(destination),
            U256::from(40u64)
        );
        assert_eq!(
            token.sender(source).balance_of(vesting.address()),
            U256::from(40u64)
        );

        // unlock rest of tranches
        vesting
            .sender(source)
            .unlock(schedule_id, 0, 3)
            .motsu_unwrap();

        assert_eq!(
            token.sender(source).balance_of(destination),
            U256::from(80u64)
        );
        assert_eq!(
            token.sender(source).balance_of(vesting.address()),
            U256::ZERO
        );
    }
}</code></pre>
<p>Test the access control logic for the permissioned functions:</p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    // ...

    #[motsu::test]
    fn test_change_destination(
        token: Contract&lt;Erc20&gt;,
        vesting: Contract&lt;TokenVestingContract&gt;,
        owner: Address,
        source: Address,
        destination: Address,
        new_destination: Address,
    ) {
        setup_env(&amp;token, source);

        let vesting_amount = U256::from(40u64);
        token
            .sender(source)
            .approve(vesting.address(), vesting_amount)
            .motsu_unwrap();

        let schedule = vec![(100u64, U256::from(20u64)), (200u64, U256::from(20u64))];

        let schedule_id = vesting
            .sender(source)
            .create(token.address(), owner, destination, schedule)
            .motsu_unwrap();

        // Test 1: Unauthorized change (not owner)
        let err = vesting
            .sender(source)
            .change_destination(schedule_id, new_destination)
            .motsu_unwrap_err();
        assert!(matches!(err, ContractError::Unauthorized(_)));

        // Test 2: Authorized change by owner
        vesting
            .sender(owner)
            .change_destination(schedule_id, new_destination)
            .motsu_unwrap();

        assert_eq!(
            vesting.sender(owner).destination(schedule_id),
            new_destination
        );

        // Test 3: Unlock tokens to new destination
        VM::context().set_block_timestamp(150);
        vesting
            .sender(owner)
            .unlock(schedule_id, 0, 1)
            .motsu_unwrap();

        assert_eq!(
            token.sender(source).balance_of(new_destination),
            U256::from(20u64)
        );
        assert_eq!(token.sender(source).balance_of(destination), U256::ZERO);
    }

    #[motsu::test]
    fn test_change_owner(
        token: Contract&lt;Erc20&gt;,
        vesting: Contract&lt;TokenVestingContract&gt;,
        owner: Address,
        new_owner: Address,
        source: Address,
        destination: Address,
    ) {
        setup_env(&amp;token, source);

        token
            .sender(source)
            .approve(vesting.address(), U256::from(20u64))
            .motsu_unwrap();

        let schedule = vec![(100u64, U256::from(20u64))];

        let schedule_id = vesting
            .sender(source)
            .create(token.address(), owner, destination, schedule)
            .motsu_unwrap();

        // Test 1: Unauthorized change
        let err = vesting
            .sender(source)
            .change_owner(schedule_id, new_owner)
            .motsu_unwrap_err();
        assert!(matches!(err, ContractError::Unauthorized(_)));

        // Test 2: Authorized change by current owner
        vesting
            .sender(owner)
            .change_owner(schedule_id, new_owner)
            .motsu_unwrap();

        assert_eq!(vesting.sender(new_owner).owner(schedule_id), new_owner);

        // Test 3: New owner can now change destination
        let another_destination = Address::from([5u8; 20]);
        vesting
            .sender(new_owner)
            .change_destination(schedule_id, another_destination)
            .motsu_unwrap();

        assert_eq!(
            vesting.sender(new_owner).destination(schedule_id),
            another_destination
        );
    }
}    </code></pre>
<p>Additional tests include exercising schedule creation input validation, state isolation of schedules and correct handling of non-existant schedule identifiers:</p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
   // ...

   #[motsu::test]
   fn test_create_validation_errors(
       token: Contract&lt;Erc20&gt;,
       vesting: Contract&lt;TokenVestingContract&gt;,
       owner: Address,
       source: Address,
       destination: Address,
   ) {
       setup_env(&amp;token, source);

       // Test 1: Invalid token (zero address)
       let err = vesting
           .sender(source)
           .create(
               Address::ZERO,
               owner,
               destination,
               vec![(100u64, U256::from(20u64))],
           )
           .motsu_unwrap_err();
       assert!(matches!(err, ContractError::InvalidToken(_)));

       // Test 3: Invalid destination (zero address)
       let err = vesting
           .sender(source)
           .create(
               token.address(),
               owner,
               Address::ZERO,
               vec![(100u64, U256::from(20u64))],
           )
           .motsu_unwrap_err();
       assert!(matches!(err, ContractError::InvalidDestination(_)));

       // Test 4: Empty schedule
       let err = vesting
           .sender(source)
           .create(token.address(), owner, destination, vec![])
           .motsu_unwrap_err();
       assert!(matches!(err, ContractError::InvalidSchedule(_)));

       // Test 5: Zero amount in schedule
       let err = vesting
           .sender(source)
           .create(
               token.address(),
               owner,
               destination,
               vec![(100u64, U256::ZERO)],
           )
           .motsu_unwrap_err();
       assert!(matches!(err, ContractError::InvalidSchedule(_)));

       // Test 6: Non-chronological schedule
       let err = vesting
           .sender(source)
           .create(
               token.address(),
               owner,
               destination,
               vec![
                   (200u64, U256::from(10u64)),
                   (100u64, U256::from(10u64)), // Earlier timestamp after later one
               ],
           )
           .motsu_unwrap_err();
       assert!(matches!(err, ContractError::InvalidSchedule(_)));

       // Test 7: Insufficient allowance
       token
           .sender(source)
           .approve(vesting.address(), U256::from(10u64))
           .motsu_unwrap();

       let err = vesting
           .sender(source)
           .create(
               token.address(),
               owner,
               destination,
               vec![(100u64, U256::from(20u64))], // Needs 20 but only approved 10
           )
           .motsu_unwrap_err();
       assert!(matches!(err, ContractError::TokenDepositFailed(_)));
   }

   #[motsu::test]
   fn test_multiple_schedules(
       token: Contract&lt;Erc20&gt;,
       vesting: Contract&lt;TokenVestingContract&gt;,
       owner1: Address,
       owner2: Address,
       source: Address,
       destination1: Address,
       destination2: Address,
   ) {
       setup_env(&amp;token, source);

       // Create first schedule
       token
           .sender(source)
           .approve(vesting.address(), U256::from(30u64))
           .motsu_unwrap();

       let schedule_id1 = vesting
           .sender(source)
           .create(
               token.address(),
               owner1,
               destination1,
               vec![(100u64, U256::from(30u64))],
           )
           .motsu_unwrap();

       // Create second schedule
       token
           .sender(source)
           .approve(vesting.address(), U256::from(50u64))
           .motsu_unwrap();

       let schedule_id2 = vesting
           .sender(source)
           .create(
               token.address(),
               owner2,
               destination2,
               vec![(200u64, U256::from(50u64))],
           )
           .motsu_unwrap();

       // Verify separate schedule IDs
       assert_eq!(schedule_id1, U256::from(1u64));
       assert_eq!(schedule_id2, U256::from(2u64));
       assert_eq!(vesting.sender(source).schedule_count(), U256::from(2u64));

       // Verify schedules are independent
       assert_eq!(vesting.sender(source).owner(schedule_id1), owner1);
       assert_eq!(vesting.sender(source).owner(schedule_id2), owner2);
       assert_eq!(
           vesting.sender(source).destination(schedule_id1),
           destination1
       );
       assert_eq!(
           vesting.sender(source).destination(schedule_id2),
           destination2
       );

       // Unlock first schedule
       VM::context().set_block_timestamp(150);
       vesting
           .sender(source)
           .unlock(schedule_id1, 0, 1)
           .motsu_unwrap();
       assert_eq!(
           token.sender(source).balance_of(destination1),
           U256::from(30u64)
       );
       assert_eq!(token.sender(source).balance_of(destination2), U256::ZERO);

       // Unlock second schedule
       VM::context().set_block_timestamp(200);
       vesting
           .sender(source)
           .unlock(schedule_id2, 0, 1)
           .motsu_unwrap();
       assert_eq!(
           token.sender(source).balance_of(destination1),
           U256::from(30u64)
       );
       assert_eq!(
           token.sender(source).balance_of(destination2),
           U256::from(50u64)
       );
   }

   #[motsu::test]
   fn test_nonexistent_schedule_operations(
       vesting: Contract&lt;TokenVestingContract&gt;,
       caller: Address,
       new_destination: Address,
       new_owner: Address,
   ) {
       let nonexistent_id = U256::from(999u64);

       // Test unlock on nonexistent schedule
       let err = vesting
           .sender(caller)
           .unlock(nonexistent_id, 0, 1)
           .motsu_unwrap_err();
       assert!(matches!(err, ContractError::ScheduleNotFound(_)));

       // Test change_destination on nonexistent schedule
       let err = vesting
           .sender(caller)
           .change_destination(nonexistent_id, new_destination)
           .motsu_unwrap_err();
       assert!(matches!(err, ContractError::ScheduleNotFound(_)));

       // Test change_owner on nonexistent schedule
       let err = vesting
           .sender(caller)
           .change_owner(nonexistent_id, new_owner)
           .motsu_unwrap_err();
       assert!(matches!(err, ContractError::ScheduleNotFound(_)));

       // Test view functions return sensible defaults
       assert_eq!(vesting.sender(caller).token(nonexistent_id), Address::ZERO);
       assert_eq!(vesting.sender(caller).owner(nonexistent_id), Address::ZERO);
       assert_eq!(
           vesting.sender(caller).destination(nonexistent_id),
           Address::ZERO
       );
       assert_eq!(vesting.sender(caller).schedule(nonexistent_id), vec![]);
   }
}    </code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-and-debugging"><a class="header" href="#testing-and-debugging">Testing and Debugging</a></h1>
<h2 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h2>
<p>Test harnesses for Solana programs, such as <a href="https://github.com/LiteSVM/litesvm">LiteSVM</a> or <a href="https://github.com/anza-xyz/mollusk">Mollusk</a>, require loading the target program binary, as well any dependency program binaries, into a cut down implementation of the Solana Virtual Machine (SVM).</p>
<p>In contrast, Stylus contracts can be tested by instantiating the contract with a mock <a href="https://docs.rs/stylus-sdk/0.9.2/stylus_sdk/prelude/trait.Host.html"><code>Host</code></a> trait implementation without needing to first build the WASM binary.</p>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p>In order for the contract to be instantiated from a test <code>Host</code> implementation, the <code>stylus-test</code> feature must be enabled for the <code>stylus-sdk</code> dependency. This ensures that the <code>#[storage]</code> attribute macro, applied to the top-level contract struct, <a href="https://github.com/OffchainLabs/stylus-sdk-rs/blob/975c8349598d2bdb3a12d91455315bd12305d132/stylus-proc/src/macros/storage.rs#L202-L231">generates</a> the <code>From&lt;&amp;HostImpl&gt;</code> implementation.</p>
<blockquote>
<p>Note: The coupling of the test setup implementation with the <code>#[storage]</code> macro allows a contract to be split into sub-components that can be independently instantiated and tested. This pattern is used extensively by OpenZeppelin, an example of which is the <code>Ownable</code> component <a href="https://github.com/OpenZeppelin/rust-contracts-stylus/blob/47ad80064cf37be08ae714257695ba281e5471ad/contracts/src/access/ownable.rs#L284-L432">tests</a>.</p>
</blockquote>
<p>While the <a href="https://docs.rs/stylus-test/0.9.2/stylus_test/vm/struct.TestVM.html"><code>TestVM</code></a> provided in the <code>stylys_sdk::testing</code> module is sufficient for simple contracts, versions up to <code>0.9.0</code> do not support the use of interfaces to call external contracts.</p>
<p>The <a href="https://docs.rs/motsu/latest/motsu/index.html"><code>motsu</code></a> test harness library, developed by OpenZeppelin, allows for the use of interfaces and the testing of the interaction between multiple contracts, as well as improved test setup ergonomics. This is particularly useful if the contract under test uses ERC20 or ERC721 tokens.</p>
<pre><code class="language-toml">[package]
# ...

[dependencies]
alloy-primitives = "=0.8.20"
alloy-sol-types = "=0.8.20"
stylus-sdk = "0.9.0"

[dev-dependencies]
alloy-primitives = { version = "=0.8.20" features = [ "tiny-keccak" ] }
# required for motsu
arbitrary = { version = "1.4.2", features = [ "derive" ] } 
motsu = "0.10.0"
</code></pre>
<blockquote>
<p>Note: Adding <code>motsu</code> to <code>dev-dependencies</code> implicitly enables the <code>stylus-test</code> feature via an <a href="https://github.com/OpenZeppelin/stylus-test-helpers/blob/4e6082ece6e0e1e45e2dac53c195ca878d0a1742/Cargo.toml#L31-L33">indirect dependency</a>.</p>
</blockquote>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>The following test shows how <code>motsu</code> can be used to test contracts that accept ERC20 deposits, such as the <a href="./fungible-tokens.html#allowance-system">ERC20 Allowance example</a>.</p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;

    use alloy_primitives::U256;
    use motsu::prelude::*;
    use openzeppelin_stylus::token::erc20::{
        ERC20InsufficientAllowance, Erc20, Error as Erc20Error, IErc20,
    };
    use stylus_sdk::call::MethodError;

    pub const TOTAL_SUPPLY: u64 = 1_000_000_000_000_000;

    #[motsu::test]
    fn test_contract(
        stake_token: Contract&lt;Erc20&gt;,
        stake_contract: Contract&lt;StakeErc20Contract&gt;,
        alice: Address,
    ) {
        stake_token
            .sender(alice)
            ._mint(alice, U256::from(TOTAL_SUPPLY))
            .motsu_unwrap();

        stake_contract
            .sender(alice)
            .constructor(stake_token.address());

        // Verify initial state
        assert_eq!(
            stake_token.sender(alice).total_supply(),
            U256::from(TOTAL_SUPPLY)
        );
        assert_eq!(
            stake_token.sender(alice).balance_of(alice),
            U256::from(TOTAL_SUPPLY)
        );
        assert_eq!(
            stake_contract.sender(alice).staked_balance_of(alice),
            U256::ZERO
        );
        assert_eq!(
            stake_token
                .sender(alice)
                .balance_of(stake_contract.address()),
            U256::ZERO
        );

        // Calculate stake amount (1/2 of total supply)
        let stake_amount = U256::from(TOTAL_SUPPLY / 2);
        let remaining_balance = U256::from(TOTAL_SUPPLY / 2);

        // Give stake contract allowance to transfer 1/2 of the total supply
        stake_token
            .sender(alice)
            .approve(stake_contract.address(), stake_amount)
            .motsu_unwrap();

        // Stake 1/2 of the total supply
        stake_contract
            .sender(alice)
            .stake(stake_amount)
            .motsu_unwrap();

        // Verify balances after staking
        assert_eq!(
            stake_token.sender(alice).balance_of(alice),
            remaining_balance
        );
        assert_eq!(
            stake_contract.sender(alice).staked_balance_of(alice),
            stake_amount
        );
        assert_eq!(
            stake_token
                .sender(alice)
                .balance_of(stake_contract.address()),
            stake_amount
        );

        // Attempt to stake more than available balance - should fail
        let err = stake_contract
            .sender(alice)
            .stake(stake_amount)
            .motsu_unwrap_err();
        assert_eq!(
            err,
            Erc20Error::InsufficientAllowance(ERC20InsufficientAllowance {
                spender: stake_contract.address(),
                allowance: U256::ZERO,
                needed: stake_amount
            })
            .encode()
        );

        // Unstake the full staked amount
        stake_contract
            .sender(alice)
            .unstake(stake_amount)
            .motsu_unwrap();

        // Verify balances after unstaking
        assert_eq!(
            stake_token.sender(alice).balance_of(alice),
            U256::from(TOTAL_SUPPLY)
        );
        assert_eq!(
            stake_contract.sender(alice).staked_balance_of(alice),
            U256::ZERO
        );
        assert_eq!(
            stake_token
                .sender(alice)
                .balance_of(stake_contract.address()),
            U256::ZERO
        );

        // Attempt to unstake when no tokens are staked - should fail
        let err = stake_contract
            .sender(alice)
            .unstake(stake_amount)
            .motsu_unwrap_err();
        assert!(matches!(err, ContractError::InsufficientStakedBalance(_)));
    }
}</code></pre>
<h2 id="debugging-techniques"><a class="header" href="#debugging-techniques">Debugging Techniques</a></h2>
<h3 id="using-the-dbg-macro"><a class="header" href="#using-the-dbg-macro">Using the <code>dbg!</code> macro</a></h3>
<p>As Stylus contracts are unit tested in the same fashion as conventional Rust code, not within a specialized VM like Solana programs, the standard library's <a href="https://doc.rust-lang.org/stable/std/macro.dbg.html"><code>dbg!</code> macro</a> can be inserted into the code under test to aid in debugging.</p>
<p>In Rust development, it is best practice to remove <code>dbg!</code> macro usage before committing code in version control.</p>
<h3 id="using-the-console-macro"><a class="header" href="#using-the-console-macro">Using the console! macro</a></h3>
<p>Similar to the <code>msg!</code> logging macro in Solana programs, the <a href="https://docs.rs/stylus-sdk/latest/stylus_sdk/macro.console.html"><code>console!</code> macro</a> can be used to add log messages within function execution. Messages emitted with <code>console!</code> will be readable in the testing node logs during integration testing.</p>
<p>The <code>console!</code> macro implementation is <a href="https://github.com/OffchainLabs/stylus-sdk-rs/blob/975c8349598d2bdb3a12d91455315bd12305d132/stylus-sdk/src/debug.rs#L22-L36">elided</a> unless the <code>debug</code> feature is enabled in <code>stylus-sdk</code>. This means it is safe to commit code containing <code>console!</code> usage.</p>
<p>The following is an example of how to conditionally enable the <code>debug</code> feature:</p>
<pre><code class="language-toml">[package]
# ...

[features]
debug = ["stylus-sdk/debug"]

[dependencies]
# ... 
stylus-sdk = "0.9.0"
</code></pre>
<p>To build a WASM artifact with <code>console!</code> logging enabled for integration testing, the following command structure can be used:</p>
<pre><code class="language-bash">cargo build --features debug --release
</code></pre>
<blockquote>
<p>Note: Additional WASM artifact size optimization may be required. Refer to the <a href="https://docs.arbitrum.io/stylus/how-tos/optimizing-binaries">official Stylus documentation</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gas-optimization"><a class="header" href="#gas-optimization">Gas optimization</a></h1>
<p>This chapter covers strategies to reduce gas consumption with specific focus on how gas usage differs from Solana's compute unit model.</p>
<h2 id="compute-units-vs-gas--ink"><a class="header" href="#compute-units-vs-gas--ink">Compute Units vs Gas &amp; Ink</a></h2>
<p>The fundamental difference between Solana and Ethereum/Stylus fee models:</p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Solana</th><th>Stylus/Ethereum</th></tr></thead><tbody>
<tr><td><strong>Unit</strong></td><td>Compute Units (CU)</td><td>Gas (and ink in Stylus VM)</td></tr>
<tr><td><strong>Pricing</strong></td><td>Fixed: 5,000 Lamports (0.000005 SOL) per signature</td><td>Variable: Gas price fluctuates with network demand</td></tr>
<tr><td><strong>Limits</strong></td><td>Per-transaction: 1.4M CU max</td><td>Per-block gas limit: ~30M gas</td></tr>
<tr><td><strong>Measurement</strong></td><td>Instruction-based (each instruction deducts from CU budget)</td><td>Operation-based (WASM opcodes measured in ink)</td></tr>
<tr><td><strong>State Access</strong></td><td>Rent-exempt deposits (one-time, refundable)</td><td>Per-operation gas cost (with SDK caching optimization)</td></tr>
<tr><td><strong>Optimization Focus</strong></td><td>Reduce CU usage and account size</td><td>Reduce storage operations; leverage compute efficiency</td></tr>
</tbody></table>
</div>
<h3 id="stylus-specific-concepts"><a class="header" href="#stylus-specific-concepts">Stylus-Specific Concepts</a></h3>
<p>Stylus introduces <strong>ink</strong> as a sub-gas unit for measuring WASM execution:</p>
<ul>
<li><strong>1 gas = 10,000 ink</strong> (configurable exchange rate)</li>
<li>WASM opcodes are orders of magnitude faster than EVM opcodes, thus requiring fractional gas in the form of ink.</li>
</ul>
<p><strong>Cost Advantages in Stylus vs EVM:</strong></p>
<ul>
<li><strong>Compute</strong>: 10-100x cheaper than EVM due to WASM efficiency and compiled Rust/C/C++ code quality</li>
<li><strong>Memory</strong>: 100-500x cheaper with novel exponential pricing (vs. EVM's quadratic per-call model)</li>
<li><strong>Storage</strong>: SLOAD/SSTORE cost the same as EVM, but Stylus SDK implements optimal caching to minimize operations</li>
</ul>
<p><strong>Stylus Storage Cache:</strong></p>
<p>The Stylus VM implements an <a href="https://github.com/OffchainLabs/nitro/blob/master/arbitrator/arbutil/src/evm/storage.rs#L35-L61">storage cache</a> that dramatically reduces the cost of repeated storage access:</p>
<ul>
<li><strong>Storage reads</strong>: First 32 reads are free (0 gas), reads 33-128 cost 2 gas each, subsequent reads cost 10 gas each</li>
<li><strong>Storage writes</strong>: First 8 writes are free (0 gas), writes 9-64 cost 7 gas each, subsequent writes cost 10 gas each</li>
<li><strong>Cache mechanics</strong>: The <a href="https://github.com/OffchainLabs/nitro/blob/92445764cb0df9f22cf6861d7f7260903b72302b/arbitrator/arbutil/src/evm/req.rs#L103-L152"><code>StorageCache</code></a> is used to track the value of accessed slots, with dirty writes batched and flushed to the host EVM</li>
<li><strong>Per-transaction scope</strong>: Cache persists for the duration of a single transaction/call, resetting between calls</li>
</ul>
<p>This caching strategy means repeatedly accessing the same storage slots within a transaction is nearly free after the initial access, unlike standard EVM where each warm SLOAD costs 100 gas.</p>
<p><strong>Cost Comparison:</strong></p>
<p><strong>Solana:</strong></p>
<ul>
<li>Base transaction fee: 5,000 Lamports (0.000005 SOL) per signature</li>
<li>Simple transfer: ~300 CU (when optimized with <code>SetComputeUnitLimit</code>)</li>
<li>System program CPI: ~2,215 CU</li>
<li>Token transfer (direct): ~3,000 CU</li>
<li>Token transfer via CPI: ~4,100 CU (adds ~1,000 CU overhead)</li>
<li>Account creation requires rent-exempt deposit based on data size:
<ul>
<li>Empty account: ~890,880 Lamports (~0.00089 SOL)</li>
<li>32-byte account: ~1,113,600 Lamports (~0.0011 SOL)</li>
<li>Deposits are fully refundable when accounts are closed</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: Unlike EVM/Stylus the amount of compute units used does not affect the overall transaction fee but it does affect the block inclusion latency. The lower the compute unit usage, the higher the reward ratio for validators to include the transaction in a block based on the fixed base fee plus any proposed priority fee.</p>
</blockquote>
<p><strong>Stylus:</strong></p>
<ul>
<li>Simple I32Add: 70 ink = 0.007 gas</li>
<li>Simple I64Add: 100 ink = 0.01 gas</li>
<li>Keccak hash: 121,800 + 21,000w ink (w = EVM words)</li>
<li>Storage operations with SDK caching:
<ul>
<li>First 32 reads: 0 gas (cached)</li>
<li>First 8 writes: 0 gas (cached)</li>
<li>Subsequent cached reads: 2-10 gas</li>
<li>Subsequent cached writes: 7-10 gas</li>
<li>Cold SLOAD (first access, not in cache): ~2,100 gas (EVM standard)</li>
<li>Cold SSTORE (first write): ~20,000 gas new slot, ~5,000 gas update (EVM standard)</li>
</ul>
</li>
<li>Host I/O call overhead: ~0.84 gas per host function invocation</li>
<li>External contract call: 128-2,048 gas base overhead</li>
<li>WASM contract entry: 128-2,048 gas per Stylus contract call</li>
</ul>
<blockquote>
<p>Note: due to the gas overhead of entering the WASM VM when calling a Stylus contract, it may be cheaper gas-wise to use Solidity for trivial contracts.</p>
</blockquote>
<h2 id="optimization-techniques"><a class="header" href="#optimization-techniques">Optimization Techniques</a></h2>
<p>With industry-leading compiler technology compiling contracts to WASM, assembly-level gas optimizations common in Solidity/EVM development are not required.</p>
<p>As a general principle, favor code readability and simplicity over premature optimization. However, <strong>field ordering matters</strong> when working with storage.</p>
<h3 id="storage-slot-packing"><a class="header" href="#storage-slot-packing">Storage Slot Packing</a></h3>
<p>The Stylus SDK's <code>#[storage]</code> macro automatically packs storage fields efficiently, but it can only pack <strong>adjacent fields</strong>. The macro processes fields sequentially and cannot reorder them, so the order you declare fields determines the storage layout.</p>
<pre><code class="language-rust">#[storage]
pub struct EfficientStorage {
    flag1: StorageBool,  // Slot 0, byte 0
    flag2: StorageBool,  // Slot 0, byte 1
    x: StorageU256,      // Slot 1, bytes 0-31
}

#[storage]
pub struct InefficientStorage {
    flag1: StorageBool,  // Slot 0, byte 0
    x: StorageU256,      // Slot 1, bytes 0-31
    flag2: StorageBool,  // Slot 2, byte 0 (wasted slot!)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_slot_usage() {
        assert_eq!(EfficientStorage::required_slots(), 2);
        assert_eq!(InefficientStorage::required_slots(), 3);
    }
}</code></pre>
<p><strong>Key insight:</strong> Group fields by size to fill 32-byte slots completely. When <code>flag1</code> and <code>flag2</code> are adjacent, they share a slot. When separated by <code>StorageU256</code>, each requires its own slot, wasting 31 bytes per slot.</p>
<h3 id="understanding-the-macro-expansion"><a class="header" href="#understanding-the-macro-expansion">Understanding the Macro Expansion</a></h3>
<p>The <code>#[storage]</code> macro uses a greedy packing algorithm that tracks two variables:</p>
<ul>
<li><code>space</code>: Remaining bytes in the current slot (starts at 32)</li>
<li><code>slot</code>: Current slot index (starts at 0)</li>
</ul>
<p>For each field, the macro:</p>
<ol>
<li>Checks if the field fits in remaining space</li>
<li>If not, moves to the next slot</li>
<li>Allocates the field and updates tracking variables</li>
</ol>
<p><strong>Efficient Layout Expansion:</strong></p>
<pre><code class="language-rust">impl stylus_sdk::storage::StorageType for EfficientStorage {
    unsafe fn new(
        mut root: stylus_sdk::alloy_primitives::U256,
        offset: u8,
        host: stylus_sdk::host::VM,
    ) -&gt; Self {
        let mut space: usize = 32;  // Available bytes in current slot
        let mut slot: usize = 0;    // Current slot index
        
        let accessor = Self {
            __stylus_host: host.clone(),
            
            flag1: {
                let bytes = &lt;StorageBool as storage::StorageType&gt;::SLOT_BYTES;      // = 1 byte
                let words = &lt;StorageBool as storage::StorageType&gt;::REQUIRED_SLOTS;  // = 0 (number of full slots required)
                
                if space &lt; bytes {  // 32 &lt; 1? → false, fits in current slot
                    space = 32;
                    slot += 1;
                }
                space -= bytes;  // 32 - 1 = 31 bytes remaining
                
                let root = root + alloy_primitives::U256::from(slot);  // slot = 0
                let field = &lt;StorageBool as storage::StorageType&gt;::new(
                    root,
                    space as u8,  // offset = 31
                    host.clone(),
                );
                
                if words &gt; 0 {  // 0 &gt; 0? → false, no full slots consumed
                    slot += words;
                    space = 32;
                }
                field
            },
            
            flag2: {
                let bytes = &lt;StorageBool as storage::StorageType&gt;::SLOT_BYTES;      // = 1 byte
                let words = &lt;StorageBool as storage::StorageType&gt;::REQUIRED_SLOTS;  // = 0
                
                if space &lt; bytes {  // 31 &lt; 1? → false, still fits
                    space = 32;
                    slot += 1;
                }
                space -= bytes;  // 31 - 1 = 30 bytes remaining
                
                let root = root + alloy_primitives::U256::from(slot);  // slot = 0
                let field = &lt;StorageBool as storage::StorageType&gt;::new(
                    root,
                    space as u8,  // offset = 30
                    host.clone(),
                );
                
                if words &gt; 0 {  // 0 &gt; 0? → false
                    slot += words;
                    space = 32;
                }
                field
            },
            
            x: {
                let bytes = &lt;StorageU256 as storage::StorageType&gt;::SLOT_BYTES;      // = 32 bytes
                let words = &lt;StorageU256 as storage::StorageType&gt;::REQUIRED_SLOTS;  // = 0
                
                if space &lt; bytes {  // 30 &lt; 32? → true, needs new slot
                    space = 32;
                    slot += 1;  // slot = 1
                }
                space -= bytes;  // 32 - 32 = 0 bytes remaining
                
                let root = root + alloy_primitives::U256::from(slot);  // slot = 1
                let field = &lt;StorageU256 as storage::StorageType&gt;::new(
                    root,
                    space as u8,  // offset = 0
                    host.clone(),
                );
                
                if words &gt; 0 {  // 0 &gt; 0? → false
                    slot += words;
                    space = 32;
                }
                field
            },
        };
        accessor
    }
}</code></pre>
<p>Fields <code>flag1</code> and <code>flag2</code> both live in slot 0 at different byte offsets. <code>x</code> uses slot 1. Total: <strong>2 slots</strong>.</p>
<p><strong>Inefficient Layout Expansion:</strong></p>
<pre><code class="language-rust">impl stylus_sdk::storage::StorageType for InefficientStorage {
    unsafe fn new(
        mut root: stylus_sdk::alloy_primitives::U256,
        offset: u8,
        host: stylus_sdk::host::VM,
    ) -&gt; Self {
        let mut space: usize = 32;  // Available bytes in current slot
        let mut slot: usize = 0;    // Current slot index

        let accessor = Self {
            __stylus_host: host.clone(),
            
            flag1: {
                let bytes = &lt;StorageBool as storage::StorageType&gt;::SLOT_BYTES;      // = 1 byte
                let words = &lt;StorageBool as storage::StorageType&gt;::REQUIRED_SLOTS;  // = 0
                
                if space &lt; bytes {  // 32 &lt; 1? → false, fits
                    space = 32;
                    slot += 1;
                }
                space -= bytes;  // 32 - 1 = 31 bytes remaining
                
                let root = root + alloy_primitives::U256::from(slot);  // slot = 0
                let field = &lt;StorageBool as storage::StorageType&gt;::new(
                    root,
                    space as u8,  // offset = 31
                    host.clone(),
                );
                
                if words &gt; 0 {  // 0 &gt; 0? → false
                    slot += words;
                    space = 32;
                }
                field
            },
            
            x: {
                let bytes = &lt;StorageU256 as storage::StorageType&gt;::SLOT_BYTES;      // = 32 bytes
                let words = &lt;StorageU256 as storage::StorageType&gt;::REQUIRED_SLOTS;  // = 0
                
                if space &lt; bytes {  // 31 &lt; 32? → true, needs new slot
                    space = 32;
                    slot += 1;  // slot = 1
                }
                space -= bytes;  // 32 - 32 = 0 bytes remaining
                
                let root = root + alloy_primitives::U256::from(slot);  // slot = 1
                let field = &lt;StorageU256 as storage::StorageType&gt;::new(
                    root,
                    space as u8,  // offset = 0
                    host.clone(),
                );
                
                if words &gt; 0 {  // 0 &gt; 0? → false
                    slot += words;
                    space = 32;
                }
                field
            },
            
            flag2: {
                let bytes = &lt;StorageBool as storage::StorageType&gt;::SLOT_BYTES;      // = 1 byte
                let words = &lt;StorageBool as storage::StorageType&gt;::REQUIRED_SLOTS;  // = 0
                
                if space &lt; bytes {  // 0 &lt; 1? → true, needs new slot
                    space = 32;
                    slot += 1;  // slot = 2
                }
                space -= bytes;  // 32 - 1 = 31 bytes remaining
                
                let root = root + alloy_primitives::U256::from(slot);  // slot = 2
                let field = &lt;StorageBool as storage::StorageType&gt;::new(
                    root,
                    space as u8,  // offset = 31
                    host.clone(),
                );
                
                if words &gt; 0 {  // 0 &gt; 0? → false
                    slot += words;
                    space = 32;
                }
                field
            },
        };
        accessor
    }
}</code></pre>
<p>Field <code>flag1</code> uses slot 0, <code>x</code> uses slot 1, <code>flag2</code> uses slot 2. Total: <strong>3 slots</strong>, with 31 wasted bytes in slots 0 and 2.</p>
<blockquote>
<p>Best Practice: <strong>Group fields of similar sizes together to maximize slot utilization.</strong> The macro processes fields sequentially, so arrange them to minimize wasted space within each 32-byte slot. Small fields can appear before or after large fields, as long as they're grouped together to efficiently fill slots.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h1>
<p>Migrating from Solana to Stylus changes your threat model. The EVM environment exposes different attack surfaces and patterns. This chapter details the security checks and hardening steps for migrated contracts.</p>
<p>In stateless Solana programs, a potential attacker controls all of the input data that the program operates over. Extreme care has to be taken to verify keys, PDAs and accounts to ensure that an attacker cannot spoof their way into stealing program controlled funds or creating invalid account states.</p>
<p>By contrast, Stylus contracts solely control their own storage, which can be considered trusted. They must take care to verify sender access permissions and validate function parameters.</p>
<h2 id="contract-reentrancy"><a class="header" href="#contract-reentrancy">Contract reentrancy</a></h2>
<p>Unlike EVM contracts, all Stylus contract entrypoints have reentrancy disabled by default. This is implemented in the code generated by the <code>#[entrypoint]</code> macro, which expands to:</p>
<pre><code class="language-rust">#[no_mangle]
pub extern "C" fn user_entrypoint(len: usize) -&gt; usize {
    let host = stylus_sdk::host::VM(stylus_sdk::host::WasmVM {});
    if host.msg_reentrant() {
        // Returning 1 indicates an error occured and the transaction will be reverted
        return 1;
    }
    host.pay_for_memory_grow(0);
    let input = host.read_args(len);
    let (data, status) = match __stylus_struct_entrypoint(input, host.clone()) {
        Ok(data) =&gt; (data, 0),
        Err(data) =&gt; (data, 1),
    };
    host.flush_cache(false);
    host.write_result(&amp;data);
    status
}</code></pre>
<p>Enabling the <code>reentrant</code> feature for <code>stylus-sdk</code> instructs the <code>#[entrypoint]</code> macro to <a href="https://github.com/OffchainLabs/stylus-sdk-rs/blob/975c8349598d2bdb3a12d91455315bd12305d132/stylus-proc/src/macros/entrypoint.rs#L178-L192">not generate the blanket reentrancy check</a>. In the rare occasion that reentrancy is required for functions, extreme care must be taken to ensure non-reentrant functions manually deny reentrant calls by using the <a href="https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/trait.MessageAccess.html#tymethod.msg_reentrant"><code>MessageAccess::msg_reentrant</code></a> check. Any reentrant function needs to ensure that any storage writes are performed and the storage cache is <a href="https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/trait.StorageAccess.html#tymethod.flush_cache">explicitly flushed</a> <em>before</em> making the external call.</p>
<h2 id="integer-arithmetic-overflow"><a class="header" href="#integer-arithmetic-overflow">Integer Arithmetic Overflow</a></h2>
<p>By far the most commonly discovered vulnerability in Stylus audits is the use of unchecked arithmetic functions (<code>+, -, *, &lt;&lt;, &gt;&gt;</code> and their associated trait methods in <a href="https://doc.rust-lang.org/stable/std/ops/index.html#traits"><code>std::ops</code></a>) on integer types, which silently wrap around in release builds.</p>
<p>It is best practice to used the explicitly checked variants of arithmetic functions, by convention named <code>checked_*</code> where <code>*</code> is a placeholder for the operation. The contract should then either explicitly panic if an overflow should be impossible given the business logic invariants or otherwise return an error, reverting the transaction in both cases.</p>
<p>Examples of Stylus audit findings concerning integer arithmetic overflow include:</p>
<ul>
<li>Renegade: <a href="https://github.com/renegade-fi/renegade/blob/ec0a556cd0faa4bff84553204d4811c72eb3f693/audits/zksecurity-10-25-24.pdf">00 - Transfer Amount Underflow Can Lead to Loss of Funds</a></li>
<li>OpenZeppelin Stylus Contracts: <a href="https://github.com/OpenZeppelin/rust-contracts-stylus/blob/f81c2fb4cbf427e4d95471a2956b9b27faf31543/audits/Stylus%20Contracts%20Library%20v0.2.0%20Audit.pdf">H-01 Limb Shift Overflow in <code>shr_assign</code> and <code>shl_assign</code></a></li>
</ul>
<h2 id="sender-authorization"><a class="header" href="#sender-authorization">Sender Authorization</a></h2>
<p>When employing access control patterns, ensure that <a href="https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/trait.MessageAccess.html#tymethod.msg_sender"><code>MessageAccess::msg_sender</code></a> is used when checking that the caller matches the stored authority address.</p>
<p>The exception to this rule is when you are retrieving the creator address of a contract within the <code>constructor</code> function, in this case <a href="https://docs.rs/stylus-sdk/latest/stylus_sdk/prelude/trait.MessageAccess.html#tymethod.tx_origin"><code>MessageAccess::tx_origin</code></a> should be used because <code>MessageAccess::msg_sender</code> returns the Stylus contract factory address in production.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
