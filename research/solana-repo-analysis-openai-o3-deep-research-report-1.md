# Solana Program Repository Analysis

## Structural Patterns in Program Layout

On-chain Solana program crates tend to follow a consistent project structure. Almost every program includes a src/ directory with a core library file (lib.rs) and a set of standard modules. A common pattern is to have an entrypoint (often entrypoint.rs) that defines the program's entry function and delegates to a processor or handler. The main business logic is typically organized in a processor module (either a single processor.rs or a subdirectory of handlers). Many programs define an instruction dispatch function (often process_instruction) in the processor, which routes incoming instructions to the appropriate handler. For example, the Squads Protocol program has an entrypoint.rs calling into a processor/ folder containing separate files for each instruction (e.g. process_create_squad.rs, process_cast_vote.rs, etc.). In simpler programs, a single processor.rs or even the lib.rs handles all instructions.

**State and Error Modules:** It is very common to see a state module (either state.rs or a state/ directory) defining the data structures for accounts and other persistent state. These structs are typically annotated for Borsh serialization. For example, an NFT minting program might have a state.rs to track minted tokens, while a governance program defines structs for proposals, votes, etc., in a state/ folder. Error handling is usually encapsulated in a dedicated file (error.rs or sometimes errors.rs) declaring a custom error enum. The thiserror crate is widely used to easily derive error messages and integrate with Solana's ProgramError type. As a result, programs have clear, descriptive errors (e.g. TokenError, VaultError) rather than opaque codes.

**Instruction Definitions:** There are two prevalent approaches to organizing instruction definitions. Many programs use a single instruction.rs module that defines the instruction enum or structs and their (de)serialization logic. This file often includes helper constructors for each instruction and checks for instruction data lengths. Other codebases prefer an instructions/ directory with one Rust module per instruction or per logical group of instructions. For instance, a complex DeFi program might have an instructions/ folder containing files like add_liquidity.rs, swap_exact_in.rs, etc., each encapsulating the building and processing of that instruction. In either case, the goal is clear separation between instruction definitions (what the instruction data and parameters are) and instruction processing (the business logic when the instruction is executed).

**Testing Structure:** About one-third of the program crates include an explicit tests/ directory with integration tests. These typically use the Solana Program Test framework to simulate a Solana cluster and verify program behavior. For example, the Slumlord flash-loan program contains a tests/ directory with submodules for common utilities and various CPI scenarios, and the Squads program includes an integration.rs test file to exercise basic flows. Not all programs have such tests – some minimalist or library-like program crates omit a test directory entirely. For instance, the Blockworks Mock Swap program consists only of a lib.rs and has no dedicated tests. In those cases, testing might be done in a higher-level crate or omitted if the code was example/PoC in nature. Overall, however, extensive testing is a notable practice: many projects employ program-specific test harness crates or modules, indicating an emphasis on correctness (often via solana-program-test and even custom test utilities).

**Separation of Concerns:** We observe a strong architectural pattern of separating concerns within programs. Entry-point logic, instruction parsing, state definitions, and error handling are cleanly separated into different modules, following Solana's recommended design. Program-Derived Address (PDA) utility functions are often placed in either the lib.rs or a dedicated utility module (e.g. pda.rs in some cases) to centralize address generation logic. This modular structure makes the programs easier to reason about: for example, the Squads Protocol splits state types into a state/ module, and each instruction's logic into its own function, with a central processor::process_instruction routing calls. Such patterns (entrypoint → processor → instruction handler → state updates) are consistent across most of the analyzed repositories, indicating a standard Solana program architecture emerging.

## Common Feature and Dependency Patterns

On-chain programs in the corpus implement a variety of DeFi and governance features, often using a common set of libraries. Table 1 summarizes some of the most common dependencies across these Solana programs and their typical purposes:

| Dependency | Purpose in Solana Programs | Prevalence |
|------------|---------------------------|------------|
| solana-program | Core Solana SDK for on-chain programs (entrypoint, account types) | Virtually all programs |
| borsh (+ borsh-derive) | Binary serialization for account data and instructions | Nearly all (standard for state) |
| thiserror | Derive macros for custom error enums (improves error handling) | Very common (most programs) |
| spl-token | SPL Token program interface (for token mint, transfer, burn CPIs) | Majority of finance-related programs |
| spl-associated-token-account | Interface for associated token accounts (ATA creation) | Used in token-centric programs |
| spl-token-2022 | Updated token program with extended features (if supported) | Included in a few projects (dual support) |
| Solana Program Test (solana-program-test, solana-sdk) | Test framework for simulating programs off-chain | Used in dev/test configs (integration tests) |
| serde (and serde_json) | Serialization for off-chain or optional in-program usage | Occasionally (for cross-compatibility) |
| Cryptography crates (e.g. libsecp256k1, sha2, ark-groth16, etc.) | Low-level cryptographic operations (signature verification, zk-SNARKs) | Rare – seen in specialized programs |
| Metaplex Token Metadata (spl-token-metadata or metaplex-token-metadata) | NFT metadata program interface (for NFT minting/updating) | Rare – used in NFT programs |

**Table 1:** Common dependencies in Solana on-chain programs and their usage. (Dependencies like solana-program, Borsh, and thiserror are ubiquitous. SPL libraries are included when token functionality is needed, and specialized crates appear only in certain domains like NFTs or cryptography.)

A few observations from the dependency patterns: virtually every program uses the Solana Program library (solana-program), which provides the definitions for accounts, entrypoint macros, and system instructions. For data serialization, Borsh is overwhelmingly the standard – it appears either directly or via borsh-derive in most Cargo manifests. This aligns with Solana's preference for Borsh in program state. Custom error types are commonly derived with thiserror, as noted earlier, to integrate nicely with the ProgramError type.

Many programs interact with tokens and therefore depend on SPL Token. For example, governance or wallet programs call into the SPL Token program for transferring tokens, minting, or checking balances. If a program needs to create associated token accounts (ATAs) for users, it will include spl-associated-token-account as well. A few projects explicitly support the newer Token-2022 standard (which adds features like non-fungible tokens, extended decimals, etc.), by including spl-token-2022 alongside the original token crate. This indicates a forward-looking design in those codebases to be compatible with upcoming token program changes.

Notably absent in this corpus are Anchor framework dependencies – none of the analyzed program crates use the Anchor SDK (anchor-lang). All programs are built with the raw Solana SDK, which suggests these teams chose fine-grained control or these might be older projects from before Anchor's popularity. Instead of Anchor's conveniences, developers manually implement instruction dispatch, account deserialization, and error handling, as evidenced by the widespread use of Borsh and explicit error enums.

**Common Functional Features:** The functionality implemented by these programs often falls into a few categories:

• **Token Swap and DEX Operations:** Several programs handle token swapping or liquidity pool logic. For example, the Squads Protocol includes an instruction to execute token swaps via integrating external AMMs (Raydium/Serum). There's also a dedicated Mock Swap program in the Autobahn repository that simply transfers two tokens between accounts to mimic a swap, intended as a basic template or testing utility. Such programs rely on SPL Token CPIs and do not perform complex pricing – e.g., the Mock Swap has "no price calculation or slippage logic… direct, deterministic token transfers". In contrast, more sophisticated swap integrations (Raydium, etc.) involve CPIs into those DEX programs rather than reimplementing AMM logic.

• **Governance and Voting:** A prominent theme is on-chain governance. The Squads Protocol program, for instance, enables decentralized group management with proposals and voting. It supports creating multisig treasury accounts, casting votes (including token-weighted voting), and executing approved proposals. This entails multi-signature support (M-of-N approvals) and complex state (records of proposals, votes, quorum rules in the state module). Custom governance programs like this often have multiple instruction handlers (create proposal, cast vote, execute proposal, etc.) and extensive PDA use to segregate each squad's data. Similarly, some programs implement simpler multisig wallets or DAOs following the pattern of using PDAs for each organization or vault and requiring multiple signatures on transactions.

• **Lending and Financial Primitives:** Some projects focus on lending/borrowing or staking mechanisms. The Slumlord program is a flash loan utility – it allows borrowing almost all lamports from a PDA-controlled account on the condition that the same transaction repays them. This program highlights strict loan repayment checks and uses PDAs to hold reserve funds and track loans. Its instruction set (e.g., Init, Borrow, Repay, CheckRepaid) is tailored to a flash loan workflow. Other crates (e.g., in Igneous Labs' Sanctum project) manage liquid staking tokens (LSTs), with features like add/remove liquidity, set protocol fees, rebalancing, etc. These DeFi programs commonly incorporate math utilities (for fee calculation, interest, etc.) and use program-derived addresses to secure funds (ensuring, for example, that only the program can sign to withdraw collateral).

• **NFT Minting and Metadata:** A smaller subset of programs deal with NFTs. For example, the GlitchPunks program (thecatrine's repository) allows minting a limited series of 1000 NFTs with a fixed fee. It integrates with the Metaplex Token Metadata program (spl-token-metadata) to create metadata accounts for each NFT minted. The presence of metaplex-token-metadata or mpl-token-metadata in dependencies is a telltale sign of NFT functionality. These NFT programs typically have instructions for minting (and maybe updating metadata or setting authorities) and they emphasize uniqueness and supply caps (e.g. ensuring no more than the max number of NFTs are created). They also charge mint fees, requiring the program to handle SOL transfers and possibly store a proceed vault PDA.

• **Programmatic Utilities and Others:** Beyond the major categories above, the corpus includes some utility programs. For example, one repository (Blockworks Foundation's Autobahn) contains an off-chain indexer (not an on-chain program) that uses gRPC streaming (yellowstone-grpc-proto) and PostgreSQL for indexing swap events. While not an on-chain program, its inclusion shows the ecosystem's need for off-chain services to complement on-chain logic. Another interesting case is the Neodyme Breakpoint Workshop, which packaged a vendored SPL Token program copy within a training program. This allowed a custom wallet program to use a local version of the token program for experimentation. Vendoring like this is unusual in production but useful in self-contained environments (e.g., for CTFs or demonstrations).

In summary, the feature set across these Solana programs is diverse – covering DeFi (swaps, lending, staking), governance (multisig, DAO, treasury), and digital assets (NFTs) – yet they rely on a fairly consistent stack of dependencies (Solana SDK, Borsh, SPL programs, etc.) to implement these features.

## Development Practices and Architectural Patterns

Examining the coding practices reveals a strong emphasis on safety, modularity, and clarity in these Solana programs:

• **Error Handling:** Nearly all programs define custom error types rather than using generic ProgramError::Custom codes. By leveraging thiserror, developers attach meaningful context to errors (e.g., InsufficientFunds, Unauthorized, etc.), which improves maintainability and debugging. Some projects also use Rust's error enums for internal logic and then map them to ProgramError. In a few cases, the anyhow crate appears, but typically only in test code or off-chain tools to simplify error propagation. On-chain, errors remain systematic and enumerated.

• **Program-Derived Addresses (PDAs):** Using PDAs is a standard practice for secure access control and namespacing. Many programs explicitly mention using PDAs for things like vault accounts, authority delegation, or state records. For example, the Squads program heavily relies on PDAs to represent each squad's governance accounts and proposal accounts, ensuring they are unique and only the program can sign to modify them. The Slumlord flash loan program derives a PDA to hold the lender pool's lamports, so that no external entity can withdraw them except through the program's logic. It's common to find utility functions like get_vault_address(seed: ...) -> Pubkey encapsulated in the code. This widespread PDA usage reflects a separation of state by program – each logical entity (vault, vote record, etc.) gets its own address derived from a program-specific seed, preventing collisions and unauthorized access.

• **Cross-Program Invocations (CPIs):** Solana programs frequently call other programs as part of their functionality, and this is well represented in the corpus. The most common CPIs are to the SPL Token program – e.g., to transfer tokens, mint or burn tokens, or set account authorities within the context of another program's operation. Many program descriptions highlight this: "utilizes SPL Token program for token operations" or "Uses invoke_signed for cross-program invocations". Governance and wallet programs call SPL Token to move assets; DeFi programs might call the Associated Token Account program to create token accounts on the fly. In advanced cases, CPIs to DEX programs (Serum, Raydium) are used to perform trades – the Squads program's swap feature is an example where CPIs trigger trades on external AMMs. Overall, CPI is used in a controlled manner: programs carefully validate accounts and then invoke external program instructions, often using invoke_signed when the program's PDA needs to sign (e.g., a vault PDA signing a token transfer). This demonstrates a composability ethos – Solana programs are built to interoperate via CPIs.

• **Testing and Simulation:** As mentioned, a significant number of projects include robust test suites. They often use solana-program-test to simulate transactions against the on-chain code. For instance, one specialized simulator program in the Autobahn project isn't a typical on-chain program at all, but rather a test harness that can replay swap transactions across multiple protocols using a "LiteSVM" (lightweight Solana VM). This indicates some teams build custom frameworks to rigorously test complex scenarios (in this case, DEX swaps on Orca, Saber, Raydium, etc.). Common patterns in tests include creating "dummy" mints and accounts (often via utility functions or macros), and verifying end-to-end flows like deposit -> some operation -> withdraw with expected outcomes. The presence of a program-test dependency in many crates underscores that high-level integration testing is a standard practice in Solana program development.

• **Configuration and Environment:** Since on-chain programs run in a constrained VM, there's no environment variable usage at runtime; however, projects handle configuration (like program IDs, constants, and feature flags) through code and build-time settings. A notable pattern is to factor out shared constants and interfaces into a separate crate. For example, the Slumlord repository uses a slumlord_interface crate that contains the program's declare_id! (program ID), instruction definitions, and error codes, which are then used by both the on-chain program and any clients/tests. This ensures consistency – the program ID and instruction layouts are not duplicated across codebases. Similarly, Marinade's Igneous Labs repository defines a marinade-keys crate for managing all the relevant pubkeys for the protocol (program IDs, account addresses). Such separation of interface from implementation is an architectural choice that improves maintainability, especially in multi-program projects. Additionally, some projects use Cargo features or separate builds for different network deployments (devnet vs mainnet), but this detail was not explicit in the reports.

• **Modular Workspace Design:** Several repositories are organized as workspaces with multiple related crates, highlighting an architectural pattern of modular design. In these cases, the on-chain program's logic might be split across a core library and the actual program entrypoint crate. For instance, Igneous Labs' Sanctum (liquid staking project) has numerous crates: a "controller-lib" for core logic, an "interface" crate for instructions, various utility crates (for token handling, math, etc.), and the program crate itself that ties them together. The Slumlord project similarly has slumlord-lib (implementing flash loan mechanics) and slumlord (the program that invokes the lib). This pattern allows unit testing the logic in a native context (by calling the library functions directly) and reusing code across programs. It's an advanced practice that yields cleaner on-chain code: the on-chain program's lib.rs can be very thin, just pulling in the library and calling an entry function, while all the heavy lifting is in a reusable lib crate. This modular approach is somewhat unique to certain teams (not all projects do it), but it stands out as a best-practice for large projects (e.g., Marinade/Sanctum or Slumlord) to manage complexity.

## Notable Outliers and Anomalies

While most Solana programs adhere to the patterns above, a few crates deviate in interesting ways:

• **Minimalist Programs:** The "Mock Swap" program (Blockworks Foundation's Autobahn repo) is an example of an extremely simple program: it consists only of a lib.rs with essentially one instruction to swap two tokens, and contains minimal error handling or validation. It even omits a test suite. The documentation explicitly notes it lacks slippage checks or access control and is meant as a prototype. This is an outlier compared to most production-grade programs which have robust checks. Its existence in the corpus likely serves educational or testing purposes, illustrating a bare-bones token swap for developers to build upon or test against.

• **Lack of Tests:** A few program crates appear to have no integration tests or examples, which is uncommon given the general emphasis on testing. For instance, some small utility programs or libraries (possibly those serving as interface crates) don't show a tests/ directory in their structure. One could infer that either testing was done elsewhere or the program was a proof-of-concept not rigorously tested. In contrast, many other programs boast "extensive test coverage". The absence of tests in certain crates (e.g., the above Mock Swap, or some interface/library crates) is an anomaly and could be due to time constraints or the program's experimental nature.

• **Unusual Dependencies:** Most on-chain programs avoid heavy dependencies, but a few stand out. The Trollup Proof-Verify program (wkennedy's Trollup repo) incorporates specialized cryptographic libraries – e.g. Arkworks' zk-SNARK toolkit (ark-bn254, ark-groth16, etc.) – in order to verify Groth16 proofs on-chain. This is far from typical token or DeFi programs and shows a unique use-case: on-chain zero-knowledge proof verification. Including those crates significantly increases complexity (and program size), and it's likely done only in niche applications like Trollup. Another instance of atypical dependency usage is the presence of yellowstone-grpc-proto and tracing in the Autobahn indexer service – however, since that is an off-chain component, it doesn't affect on-chain program logic. As for on-chain code, Metaplex's token metadata crate is an uncommon dependency, observed only in NFT-focused programs like GlitchPunks and Squads (for governance tokens that double as NFTs). Its inclusion signals NFT-related functionality and is not seen in other categories of programs. Overall, when a dependency falls outside the usual Solana/SPL set, the crate is likely doing something very specific (e.g., cryptography, external integration, or acting as a client to a program like token metadata).

• **Unique Architectural Choices:** The Neodyme Breakpoint Workshop repository is a special case designed for security training. It contains multiple small programs (levels) and notably vendors the SPL Token 3.1.0 program within its workspace. This allowed the level 4 challenge program to call into a local copy of the token program for learning purposes. In practice, production projects would simply call the real SPL Token program via CPI; vendoring it is atypical. Similarly, some projects include "simulator" or "mock" programs that aren't meant for deployment but for testing behaviors (for example, a programs/simulator crate exists to simulate DEX transactions off-chain). These serve as internal testing tools rather than user-facing programs, blurring the line between on-chain and off-chain code in the repository.

• **Multi-Crate Workspaces:** As discussed, a few repositories (Igneous Labs' Sanctum/Marinade, Squads, Slumlord) split functionality into multiple crates. In Sanctum's case, there are numerous libraries (for token handling, math, interfaces, etc.) which the main program depends on. This is an architectural outlier compared to simpler single-crate programs. The rationale is often to enable reusability and clean separation of concerns. For example, Slumlord's design with an interface crate and a lib crate means the flash loan logic can be tested natively in slumlord-lib and the slumlord program is almost just an "adapter" to expose that logic via on-chain instructions. Such designs are more common in larger, professional codebases where multiple programs share code or where the team wants to enforce very modular architecture.

In conclusion, the Solana program corpus exhibits strong common patterns – a testament to emerging best practices in Solana development – while also showing a few innovative twists (from on-chain ZK proofs to fully modular architectures). Each pattern or outlier we identified is tied to the specific needs and context of the project. For instance, a governance program like Squads naturally emphasizes multisig and voting modules, a DeFi protocol like Sanctum requires complex instruction sets for staking and rebalancing, and a one-off educational program may sacrifice thorough testing for simplicity. By attributing these patterns to their source repositories and crates, we see the rationale: security and flexibility needs drive architectural choices. Programs dealing with financial value adopt rigorous error handling and CPIs to known-good programs (SPL Token) for safety, whereas experimental projects optimize for clarity or specific functionality even if it means diverging from the norm. Each repository thus offers a piece of the larger puzzle of how Solana programs are being built in practice, and collectively, they highlight a maturity in the ecosystem's development standards.

## Sources:
• File tree and dependency excerpts from various Solana program repositories (user-provided analysis of 39 repos).
• Solana program feature descriptions and implementation notes (Squads Protocol, Slumlord flash loans, Mock Swap, etc.).
• Dependency and architecture details from Sanctum/Marinade (Igneous Labs) and Trollup ZK proof program.
• Testing and simulation practices from Blockworks Foundation Autobahn repository.
