# Analysis of Solana Program Repository Patterns

## 1. Structural Pattern Discovery

**Common Directory Layouts:** Across the 43 repositories (188 crates), most follow a similar project structure. Virtually all are Rust Cargo crates with a src/ directory containing the program code. Many projects use the Anchor framework workspace layout, having a top-level programs/ folder with each program as a sub-crate. Inside src/, it is common to organize code into subfolders for instructions and state. For example, 59 crates (≈31%) include an instructions/ directory that houses one module per instruction (with a mod.rs aggregator). Likewise, ~37 crates (≈20%) have a state/ directory for account structs and program state definitions. A significant number of crates (45, ~24%) define a dedicated error.rs file for custom error codes. Many also include utility modules (e.g. utils.rs in 29 crates) and constants modules (e.g. constants.rs in 20 crates) for shared helper functions or constant definitions. By contrast, only a handful of crates use the older non-Anchor style structure with an explicit entrypoint.rs (1 crate) or processor.rs (3 crates) for instruction dispatch – indicating that nearly all are using Anchor's convention of an implicit entrypoint via the #[program] macro rather than a manual entrypoint function.

**Typical File Name Conventions:** The majority of program crates use lib.rs as the main entrypoint and library module, exposing the program's entrypoint and declaring modules. Every crate contains a Cargo.toml with metadata and dependencies, and a lib.rs (or occasionally main.rs for binaries/CLI tools). Submodules often use mod.rs files to define the module hierarchy (e.g. an instructions/mod.rs that pulls together individual instruction files). Common file names include initialize.rs, update.rs, close.rs, etc., corresponding to instruction handlers, and state.rs or specific state files (e.g. user.rs, vault.rs) for account definitions. An error.rs file is commonly present to centralize custom error definitions for the program. This consistent naming (e.g. error.rs for errors, lib.rs for main module, mod.rs for module groupings) reflects a clear separation of concerns.

**Design Patterns in Module Structure:** There is a strong separation of concerns pattern across these codebases. Most programs isolate instruction logic from state definitions and error handling. For example, instruction handler functions (annotated with Anchor's #[derive(Accounts)] and #[instruction] macros) reside in the instructions/ folder, each implementing one high-level operation of the program. The state/ modules define account structs (often using Anchor's #[account] attribute for PDAs) and associated methods. This modular structure ensures that the code for processing instructions is kept separate from the data model. Some projects further break down instructions into sub-categories (e.g. an admin/ subfolder for administrative instructions, a user/ subfolder for user-facing instructions), indicating a design pattern of grouping related instructions. Overall, the directory layouts suggest a standard MVC-like separation: with instructions (controller logic), state (model definitions), and sometimes view analogs (if you consider events or logs as output). Utility functions (e.g. math or PDA utilities) are often placed in standalone files like utils.rs for reuse.

**Testing Structure:** Test code is present but often not inside the program crate itself. Only ~18 crates include an internal tests/ directory (for integration tests) within their file tree. Instead, a common practice is to have a separate test crate in the workspace for complex integration tests. For example, some repositories contain a dedicated crate named tests or integration-tests that houses comprehensive tests spanning multiple programs (e.g. a staking_integration-tests crate with its own Cargo.toml and tests/ directory). This approach keeps test code out of the core program crates. Crates that lack any test directory or companion test crate could be considered outliers (indicating minimal or no testing), but most major protocols have at least one integration test suite in the repo. In summary, the prevalent structural pattern is an Anchor workspace with multiple program crates, each following a consistent internal layout (src/lib.rs, optional instructions/, state/, error.rs, etc.), complemented by shared libraries (e.g. for utilities) and sometimes separate test harness crates.

**Table: Common Modules and Directories (Frequency in 188 Crates)**

| Module/Directory | Crates (count) | Description/Purpose |
|------------------|----------------|---------------------|
| instructions/ | 59 | Contains instruction handler modules. Each file = one instruction. |
| state/ | 37 | Contains account state struct definitions (program data models). |
| error.rs | 45 | Defines custom error codes/types for the program (often via Anchor's error_code). |
| utils.rs | 29 | Utility functions (helpers for math, PDAs, etc.). Sometimes a utils/ dir instead. |
| constants.rs | 20 | Defines constant values (e.g. seed prefixes, thresholds) used across the program. |
| processor.rs | 3 | Non-Anchor style instruction processor (few legacy cases). |
| entrypoint.rs | 1 | Explicit program entrypoint (legacy Solana style – Anchor uses macro instead). |

*(The above frequencies are approximate, based on the presence of these files in the provided corpus.)*

## 2. Feature and Dependency Pattern Mining

**Common Dependencies:** The Solana programs consistently rely on a core set of dependencies. The Anchor framework (anchor-lang) is by far the most ubiquitous – virtually every on-chain program crate uses Anchor (explicitly listed in ~66 crates) as the foundation for development. In Anchor workspaces, anchor-lang may be a workspace dependency, so it is present even when not explicitly enumerated. Many also include Anchor SPL (anchor-spl in ~37 crates) which provides convenient bindings for common Solana programs like SPL Token and Associated Token Account. Lower-level Solana libraries appear as well: solana-program (23 crates) and solana-sdk (14 crates) are used for core Solana types and CPI utilities, especially in crates that need direct Solana integration or in off-chain tools. Serialization is typically handled by Borsh (the default for Anchor, appearing explicitly in ~7 crates) or sometimes bincode (5 crates) for specific use-cases. Serde (21 crates) and serde_json (6 crates) are commonly included for JSON serialization, configuration parsing, or off-chain data (especially in client/utility crates).

Crates interacting with tokens frequently depend on SPL Token (spl-token in ~14 crates) and Associated Token Account (spl-associated-token-account in ~5 crates) for token account manipulation. A notable security best-practice is the inclusion of solana-security-txt (observed in at least 7 program crates) which embeds security contact info into the binary – a standard Solana approach for on-chain programs to advertise security policies. For error handling, many crates use thiserror (9 crates) to derive error types (Anchor's error code mechanism is built on thiserror), and some off-chain code uses anyhow (4 crates) for flexible error propagation.

Outside of on-chain specifics, several ancillary crates show up frequently, indicating common needs: clap (10 crates) for CLI argument parsing (used by command-line tools in the repos), tokio (9 crates) for async runtime (used in off-chain daemons or plugins), and reqwest (6 crates) for HTTP interactions (e.g. webhook integration or external API calls in plugin/daemon crates). For instance, the Clockwork Geyser plugin crate depends on tokio and reqwest to handle asynchronous webhook delivery. Logging and instrumentation is sometimes handled by tracing (3 crates) in off-chain contexts for structured logs.

**Specialized Dependencies:** Some repositories include unique or specialized crates reflecting their domain. For example, Metaplex's Token Metadata library (mpl-token-metadata) is used in ~8 crates – these are programs that handle NFTs or need to manipulate token metadata (e.g. minting an NFT or using NFTs as receipts). In one staking protocol, the Anchor SPL dependency is enabled with the "metadata" feature to allow NFT-based reward tracking. Another example is Switchboard oracle integration – at least one program brings in switchboard-v2 for oracle price feeds. Similarly, Pyth oracle SDK (pyth-sdk-solana) appears in a few crates (e.g. Pyth Network programs) for price feed data.

Several DeFi-oriented projects depend on Mango Markets v4 (mango-v4) client libraries (found in 3 crates) to integrate with Mango's lending/DEX protocol, and Jupiter for swap routing (e.g. a dependency jupiter-swap in one crate). In one liquidator/aggregator service, Jupiter and an internal "Sanctum" swap are used to route token swaps across DEXes. We also see stable-swap libraries (like stable-swap-anchor) in use for AMM math in certain protocols. These dependencies suggest that many programs leverage external protocol libraries rather than reinventing the wheel for complex financial logic.

**Standard Feature Implementations:** Many crates implement similar high-level features aligned with common Solana use cases:

• **Token Swap Execution:** A number of programs implement token exchange or swap functionality. For example, the Draffle Dispenser program provides a simple token swap mechanism with admin-defined rates (a kind of token sale/exchange). It allows an administrator to set exchange rates between two tokens and users to swap accordingly. More complex protocols integrate with DEX aggregators – e.g. one crate supports advanced swap routing across multiple liquidity sources (Jupiter, etc.), intelligently converting tokens using price oracles. Another program includes Saber stable-swap integration for efficient swapping of like-valued assets. In summary, token swap logic appears both in standalone exchange programs and as integrated functionality in trading platforms. They uniformly rely on CPIs to the SPL Token program for moving tokens and often manage internal vault accounts (using PDAs) to hold liquidity.

• **Governance / Voting:** Several repositories implement on-chain governance mechanisms or voting systems. For instance, Pyth Network's governance suite includes programs for staking and voting on proposals, as evidenced by an integration test crate describing "governance voting" functionality. These governance programs typically allow token holders to stake tokens to obtain voting power and vote on governance proposals. Another example is an on-chain DAO program enabling users to create and vote on governance proposals (some projects use the SPL Governance program, while others built custom logic). One unique case is a multi-signature wallet with timelock governance (from the Anchor examples): the SmartWallet program implements multisig approval plus a timelock on executions, effectively a form of on-chain governance for a wallet's actions. This indicates that governance features (quorum-based decision making, voting, time-delayed execution) are represented in the corpus, though only a subset of crates focus on them.

• **Multisig:** Multi-signature transaction approval is a feature of the aforementioned SmartWallet program and possibly others. The SmartWallet example (in the Anchor repo) allows a configurable set of owners to collectively approve transactions, with a threshold of signatures required. It also includes a timelock (minimum delay) before execution as an added security feature. This pattern (multisig governance) is not present in most programs, but it stands out as a reference design for secure control of funds by multiple parties. Other projects might use simpler multisig for admin keys (some programs accept multiple signers for admin actions), but an entire multisig wallet program is a specific feature showcased in one repo.

• **Logging and Error Handling:** On-chain programs use Solana's msg! logging (implicitly via Anchor's macros) to emit logs during execution, but this is not visible in the dependency list (since it's part of the runtime). Off-chain and client tools, however, explicitly include logging frameworks. We see usage of tracing in some Rust clients for structured logging, and some use the standard log crate with an env logger (though not always listed). Error handling on-chain is largely standardized by Anchor's error_code macro (which uses thiserror under the hood to define a custom error type). Many crates explicitly define their errors in an error.rs module, indicating a practice of enumerating program errors (often with codes and messages) rather than using generic ProgramError. Off-chain, error management is often done with Result and the anyhow crate for CLI tools (as seen in the Draffle CLI, which uses anyhow for error handling in a user-facing context). Consistently, the code emphasizes robust error handling: for example, the Draffle CLI highlights "secure interaction… and robust client-side logic" including error handling. Many program summaries mention comprehensive error handling as a feature, which suggests developers intentionally handle edge cases and provide clear failure modes. Logging is similarly treated as important in off-chain services – one validator tool notes it has comprehensive error handling and logging built-in.

• **gRPC / RPC Integrations:** Direct gRPC usage is not widespread, but one notable outlier is the integration of a gRPC interface for streaming data. For example, a Mango Markets monitoring service supports multi-protocol event streaming including WebSockets and gRPC. Additionally, the mention of Yellowstone's gRPC proto suggests that one project (perhaps related to Neon or another cross-chain project) included Rust bindings for gRPC service definitions – though this is not common in Solana programs, which usually rely on JSON RPC. On the other hand, RPC clients are frequently used in off-chain crates: e.g. many CLI or test crates depend on anchor-client or solana-client/solana-rpc-client to send transactions and fetch on-chain data. About 6 crates include solana-client or solana-rpc-client for RPC calls to a Solana node, and 5 use anchor-client for a higher-level Anchor-based client interface. These allow the off-chain components (CLIs, integration tests, daemons) to integrate with the Solana cluster. In summary, while on-chain programs don't use gRPC themselves, some supporting tools in the ecosystem integrate with external systems using gRPC, and most off-chain interactions use Solana's RPC interface (JSON RPC) via the official client libraries.

• **Test Harnesses:** The projects make use of standard Solana testing frameworks. A majority rely on solana-program-test, which is the Solana in-process test validator, to run integration tests. Indeed, the Anchor framework's #[tokio::test] setup under the hood uses solana-program-test to simulate a cluster. In one case, we see an alternative called LiteSVM (Lightweight Solana VM) used. The Pyth Network's integration test suite includes litesvm as a dependency and explicitly notes the use of a "simulated Solana environment (LiteSVM)" to run tests. This suggests that for complex scenarios, developers sometimes use custom or optimized simulators to test program logic. By and large, however, the standard approach is to use solana-program-test (with Anchor's conveniences) for integration testing, often writing tests in the separate test crates. These harnesses allow tests to spin up a local cluster, execute instructions, and verify state changes. The presence of tokio in test crates also indicates asynchronous tests (which aligns with how solana-program-test is async). In addition to program-test, some projects incorporate property-based testing or fuzzing style approaches – e.g. one integration test suite advertises "extensive property-based testing" and randomized testing for a staking program. This level of testing demonstrates a mature approach to program validation in these repositories.

## 3. Development Practices and Architecture

**Error Handling Conventions:** As noted, most programs define a custom error enum, either via Anchor's #[error_code] macro or manually implementing From<ProgramError>. This yields clear error messages and distinct error codes for different failure conditions. For example, a program might have an error.rs listing variants like InvalidParameter, Unauthorized, etc., each with an associated error code. The analysis shows almost every program crate has such an error module. This aligns with best practices for clarity and allows integration with tools (Anchor will print the error messages on failure). Off-chain, developers use Result<> extensively, with crates like thiserror to define error types and anyhow or eyre for aggregating errors in CLI applications. An emphasis on handling errors is evident – multiple summaries explicitly call out explicit or comprehensive error handling as an implementation highlight. This means programs check for edge cases (overflow, missing accounts, incorrect authority, etc.) and return descriptive errors, rather than using assert! or ignoring failures.

**Use of PDAs (Program Derived Addresses):** PDA usage is a fundamental pattern across these Solana programs. Almost all Anchor programs use PDAs for storing program state and for security (deriving addresses that only the program can sign for). For instance, the Draffle raffle program uses PDAs to manage raffle state accounts. Many feature descriptions mention extensive use of PDAs for various purposes: the Dispenser program uses "PDA-controlled token vaults" to hold escrowed tokens securely; a restaking protocol uses PDAs for identity mapping and staking position tracking; and the multisig wallet uses derived addresses for each proposed transaction. This widespread use of PDAs ensures that accounts are bound to specific seeds (often including user pubkeys or config constants), enforcing that only the program can manipulate them. Utility functions for PDA derivation (e.g. a pda.rs or using Anchor's Pubkey::find_program_address) are common. In fact, some crates have a dedicated file for PDA utilities. The reliance on PDAs exemplifies the separation of authority pattern: rather than using ephemeral program-derived keys or storing raw private keys, programs derive addresses deterministically to serve as secure storage or escrow accounts.

**Use of CPIs (Cross-Program Invocations):** CPIs are another common practice, facilitated by Anchor's CPI methods or direct invoke_signed calls. Many programs interact with the SPL Token program via CPI to transfer tokens, mint, burn, etc. This is essentially standard for any token-handling program (e.g., a token swap will CPI into the token program to move funds). The analysis highlights CPIs in feature lists: the Dispenser program explicitly notes it performs "cross-program invocations for token transfers" as part of its design. Some programs also call other protocols – e.g. a program might CPI into the Associated Token Account program to create token accounts, or into Token Metadata program to update metadata. We also see specialized CPIs like into a wormhole bridge or IBC program for cross-chain actions. For example, a restaking program integrates an IBC library (solana-ibc) with a CPI feature enabled to allow it to call into the IBC handler program. This indicates a practice of enabling CPI features on dependencies when needed (Anchor allows opting into CPI features for certain libraries). Overall, cross-program calls are used for composability – programs rarely operate in isolation; they invoke standard programs (token, associated token, sysvar instructions, etc.) and occasionally external protocols (e.g. oracles, bridges) as part of their core logic.

**Coding Style and Separation of Concerns:** Across the board, developers maintain a clear separation between on-chain code and off-chain code. On-chain programs (mostly in Rust, compiled to BPF) reside in their own crates with no dependency on off-chain libraries (no std use, only no_std or Anchor's subset). Off-chain tools (CLI, plugins, clients) reside in separate crates with full Rust std support and typical libraries (HTTP, async, etc.). For instance, Clockwork's repository has a plugin crate (Geyser plugin running inside a validator) and a cli crate – both are non-BPF and use things like tokio and reqwest, but the on-chain programs in the same repo (in programs/) stick to on-chain dependencies like anchor-lang. This delineation ensures the on-chain programs remain lightweight and security-auditable, while more complex logic or integration is handled off-chain. Many projects also factor their code by functionality: for example, the Pyth governance repository has multiple programs and also a CLI and tests crate, each encapsulating a part of the stack (on-chain logic, admin CLI, testing framework). The separation of concerns is also evident within on-chain code: data validation (using Anchor's account validation in the #[derive(Accounts)] structs) is kept mostly declarative, while business logic remains in the instruction handlers. Some projects use additional validation libraries (e.g. the vipers crate in the SmartWallet program for runtime assertions) to keep code safe and clear.

**Testing and CI Practices:** Many crates include a significant number of tests (either in separate crates or inline). The presence of integration test crates and the complexity of those (some mention "randomized stability testing", "edge case coverage") suggests a culture of thorough testing. Projects dealing with financial logic (DEXs, lending, etc.) have tests for various scenarios like multi-hop swaps, Oracle price changes, liquidation conditions, etc. There is also a trend of using default configuration or environment-config helpers for convenience, particularly in dev and test. For example, some utility crates use the default-env crate for configuration management, allowing the program to pick up cluster URLs or keys from environment variables. This is more relevant for off-chain code (like CLI tools that might read .env files or environment vars for config). It shows a practice of making tools configurable and environment-aware, easing development and deployment.

In summary, the development practices can be characterized by strong adherence to Anchor framework conventions, explicit error and event handling, heavy use of PDAs for security, CPIs for interoperability, clear separation between on-chain and off-chain logic, and a commitment to testing and maintainability through structured code and configuration management.

## 4. Outlier and Anomaly Detection

While most crates follow the patterns above, a few stand out as outliers or special cases in terms of structure, dependencies, or functionality:

• **Crates Missing Tests:** A minority of program crates appear to have no dedicated tests. These tend to be either extremely simple programs or utility libraries. For example, the "wallet-tester" program in the Pyth governance repo is a minimalist program with just a single test() instruction and no test suite of its own. Many program crates rely on integration tests at the workspace level, so the absence of a tests/ folder in a program crate doesn't always mean the feature is untested (it might be tested by a separate crate). However, a few utility crates and one-off programs do not show any associated tests, indicating either that they are trivial (thus low need for tests) or that testing might be a gap. These are outliers compared to the general trend where core programs have at least some integration testing. An example is the "wallet-tester" (a program just to verify wallet interactions) – it consists only of a lib.rs with minimal logic and is likely manually tested or tested via an integration suite.

• **Minimalist Crates (Single-File Programs):** Several crates are extremely minimal in structure, containing only a Cargo.toml and a src/lib.rs with all logic. These often serve a very narrow purpose. The wallet-tester mentioned above is one such case (just creates a zero-byte PDA account and returns). Another example is the Profile program in the Pyth repo, which links a Solana wallet to an Ethereum address – it also only has a lib.rs with a couple of instructions. These minimalist programs usually implement one or two simple instructions (no complex module breakdown) and thus don't need a multi-file structure. They are outliers in that they lack the rich subdirectory organization; essentially, they embody the "one file does everything" approach. This can be by design for clarity and brevity. For instance, the wallet-tester's simplicity (always succeeding on a test() call) is intentional, serving as a canary program to test transaction flow. Such crates demonstrate that not all programs are large – some are purpose-built tools or examples, kept minimal for ease of review.

• **Unusual Dependency Graphs:** Most programs stick to a standard set of crates, but a few bring in very atypical dependencies:
  • The Metaplex Token Metadata crate (mpl-token-metadata) is one example – only programs dealing with NFTs pull this in. About 8 crates (mostly NFT marketplaces or any program issuing NFTs as receipts) depend on it, whereas it's irrelevant to others. Its presence in those dependency graphs marks those programs as NFT-related outliers (e.g., a staking program giving NFT reward receipts uses this).
  • The Yellowstone gRPC proto dependency (as referenced by the user) implies a crate that includes gRPC protocol definitions (possibly for an RPC service or cross-language support). While our direct analysis didn't show the string "yellowstone", one of the Mango V4 service crates clearly uses gRPC for event streaming. If a crate like yellowstone-grpc-proto was used, it would indicate an outlier project focused on providing gRPC APIs (perhaps to integrate Solana data with other systems). This is not common in Solana development, where JSON RPC is the norm, so any crate including that points to a very custom integration or a validator plugin. It's likely an outlier belonging to a specific project aiming to bridge Solana with external services.
  • Some crates use custom or less common libraries: e.g. the Clockwork Geyser plugin depends on solana-geyser-plugin-interface and uses reqwest and tokio heavily – this is unusual because it's not an on-chain program but a runtime plugin that streams account updates (markedly different from typical on-chain crates). Another dependency outlier is axum (seen in 2 crates), a web framework, suggesting an HTTP API service within a Solana project (perhaps an API server for a program). Indeed, one crate lists router.rs and uses Axum to provide HTTP routes for a token distribution service, which is quite different from the usual on-chain program – it's effectively a web backend in Rust included in the repo.
  • A few financial protocols incorporate external math or utility crates like rust_decimal (for precise decimal arithmetic, in ~6 crates) and its macros, or fixed for fixed-point math, highlighting their specialized numeric needs beyond what SPL offers.
  • We also see Wormhole integration in a few places: e.g. wormhole-anchor-sdk (4 crates) and wormhole-vaas-serde (in a test crate), indicating cross-chain messaging being an outlier feature (only relevant to projects bridging to other chains). These dependencies inflate the dependency graph with heavy protocols not seen elsewhere.

• **Unique Logic / Domain-Specific Crates:** Some programs implement very domain-specific or uncommon functionality not seen across the others:
  • **Security-Oriented Tools:** A notable one is the SmartWallet (multisig) program which uses the vipers crate – a Solana-specific assertions library – to enforce runtime conditions. Its inclusion of a timelock and advanced security checks sets it apart as a security-focused program (contrast with typical DeFi programs that don't use timelocks). Another security-related feature is the solana-security-txt usage (common but worth noting: it adds no on-chain logic except a static TXT, yet shows a security consideration practice).
  • **NFT Minting and Collections:** A few programs specifically deal with NFTs – for example, an xNFT (executable NFT) marketplace or a DAO that mints NFTs to represent positions. These have code to handle metadata, mint tokens, etc., which is unique to NFT-heavy applications. They often use the aforementioned MPL Token Metadata and have instructions like create_nft_collection or mint_nft. The presence of instructions like create_app_xnft.rs or initialize_nft_collection.rs in some file trees signals an outlier focus on NFTs vs. the majority of financial programs.
  • **Cross-Chain and Oracle Programs:** The Composable Finance "emulated light client" repository stands out by implementing Inter-Blockchain Communication (IBC) protocols and a restaking mechanism across chains. Its programs (like the restaking program) deal with cross-chain validator staking and even mint NFT receipts for staked positions – a highly specialized combination of staking, cross-chain bridging, and NFT usage. The dependency on solana-ibc is very rare (unique to that repo) and marks an outlier where a Solana program directly interfaces with an IBC implementation.
  • **Mock or Dummy Programs:** Some repositories include "example" or dummy programs used for testing or demonstration. The earlier-mentioned wallet-tester is one; another could be a mock token swap or test vault program included in a DeFi protocol's repo to simulate certain conditions. For instance, a DeFi project might have a "mock oracle" or "dummy swap" program deployed locally for testing. These tend to be minimalist and not intended for production, simply returning canned responses or simulating a subset of functionality. They deviate from normal programs in that their purpose is testing or demonstrating integration (often indicated by names like program_simulator or dummy_oracle in the file tree).
  • **Validator / Client Programs:** There are also outliers that are not smart contracts at all, but tools. For example, one repo contains a validator node CLI that manages a validator with restaking and IBC – that's an off-chain binary with capabilities unlike any other crate. Another project (Jito's repository, hinted by presence of jito-steward and tip distribution) includes a program for MEV (like a tip payment program for validators) – which has very specific logic around rewarding validators. The tip distribution program's file tree includes a lot of specialized logic (like handling carrier accounts, incentives) that is unique to the MEV use-case and not found elsewhere. Its dependency on Jito-specific crates (e.g. jito-steward) is another anomaly in the corpus.

In short, outliers can be identified by either absence of common elements (no tests, no multi-file structure) or presence of uncommon elements (special dependencies, unique domain logic). Each such case usually has a rationale:
• Minimal crates exist either for simple utility (e.g. testing wallet interactions) or as example programs.
• Unusually heavy dependency crates (Metaplex, IBC, gRPC) are there because those programs are integrating with other ecosystems (NFT marketplaces, cross-chain protocols, or providing external APIs).
• Unique logic programs (multisig, timelocks, oracle feeders, etc.) serve specific needs of their projects (security governance, price feeding) that not every project requires.

The key is that these outliers stand out against the baseline of an Anchor token program or DeFi program. They either strip things down to the bare minimum (for testability or simplicity) or expand the scope of a Solana program to do things beyond the ordinary (cross-chain communication, acting as a plugin, etc.).

## 5. Source Attribution of Notable Patterns

To ground the above observations, here are specific examples of patterns and outliers, along with their originating repository/crate and context:

• **Instructions/State Module Pattern:** E.g. the Clockwork Network program (repo 42) has a clear instructions/ directory with handlers like thread_create.rs, and a state/ module for account structs. This reflects the common Anchor program structure used in Clockwork's on-chain programs. Rationale: It separates the code for processing each instruction and managing state, improving maintainability.

• **Centralized Error Module:** Most programs, like the Meteora MSP (Marinade Staking) program, define error.rs for custom errors (e.g. "Custom error definitions for the program"). This originates from the Meteora repo's program crate and shows the practice of handling errors in one place. Rationale: Easier mapping of error codes to messages and consistent error handling across the code.

• **Token Swap Implementation:** The Draffle "Dispenser" program (repo 15) is a unique crate implementing a token swap/exchange. It defines an exchange mechanism with admin-defined rates and uses PDA token vaults. This crate's summary explicitly calls it a token exchange mechanism with swap execution. Rationale: Draffle wanted a controlled way to dispense tokens (perhaps raffle tickets or rewards), so they built a custom swap program rather than a full AMM.

• **Governance & Voting:** The Pyth Network Governance repository (repo 24) includes a staking program and an integration-test crate exercising governance voting. The test crate in that repo highlights token staking and governance voting features, showing how the Pyth team implemented on-chain voting and tested it thoroughly. Rationale: As an oracle provider, Pyth introduced governance to decentralize decisions like adding data sources or adjusting parameters, hence a need for a voting program.

• **Multisig + Timelock Program:** The Anchor examples (SmartWallet) program (from Anchor's repo) demonstrates multisig. It is referenced with features like "Multisig Transaction Approval" and a timelock. This originates from the Anchor repository's examples (repo 34 in the analysis) and serves as a template for wallet governance. Rationale: Provide the community a secure wallet program where N-of-M owners must sign off on transactions, useful for DAOs or team-managed treasuries.

• **Off-chain Geyser Plugin:** The Clockwork Plugin crate (in repo 42, Clockwork) is an outlier because it's not on-chain but runs in a validator. It depends on unusual crates like tokio and reqwest and implements a Geyser plugin interface. Rationale: Clockwork's automation platform extends validators to trigger on-chain threads, necessitating an off-chain component that listens to events and submits transactions – hence a Rust plugin with network and async capabilities not found in on-chain code.

• **Cross-Chain IBC Restaking:** The Composable Finance Restaking program (repo 34) is identified by its dependency on solana-ibc and features enabling cross-chain staking rewards. It's an outlier program that maps Solana stake accounts to another chain via IBC. Rationale: Composable wanted to let Solana users stake tokens and earn rewards from activity on a connected chain (a novel DeFi concept), so they built a unique program to handle IBC messages and NFT "receipt" tokens.

• **Use of LiteSVM in Testing:** The Pyth Staking integration-tests crate (repo 24) uses the litesvm simulator and emphasizes "Simulated Solana environment (LiteSVM)". This is a standout testing approach differing from the typical solana-program-test. Rationale: For their complex staking and governance logic, the Pyth team likely needed faster or more deterministic simulation, so they employed LiteSVM to run many test scenarios efficiently.

• **Metaplex NFT Integration:** Several programs (e.g. Meteora stable swap program or Token marketplace programs) import mpl-token-metadata. One clear instance is the Composable restaking program, which through Anchor SPL's metadata feature integrates NFT minting for staking positions. Rationale: To represent staked positions or ownership, minting an NFT (with metadata like owner, amount, etc.) is convenient – these programs are the few that step into the NFT realm within primarily DeFi projects.

• **Yellowstone gRPC Proto Usage:** While not explicitly named in the text, the Mango V4 Websocket/Gateway service (part of Mango's repo) mentions gRPC streaming. If a crate named yellowstone-grpc-proto is used anywhere, it would likely be here, to define gRPC services for clients or analytics. Rationale: High-performance trading platforms like Mango benefit from streaming market data to clients; using gRPC can provide a binary, real-time feed. The proto definitions from the Yellowstone project (an initiative to standardize Solana data streaming) would facilitate that.

• **Security Contact Metadata:** At least 7 programs include the solana-security-txt crate to embed a security advisory link. For example, the Solana Season staking program (repo 23) has this in its Cargo dependencies. Rationale: As a security best practice, program developers provide a way for users to find how to report vulnerabilities. It's notable as a semi-standard practice (not all do it, so it's half-common, half-outlier).

Each pattern or anomaly traced above is backed by a specific crate's data from the corpus. These concrete attributions illustrate how different goals (DEX vs. governance vs. tooling) influence the program structure and dependencies. For instance, an order-book DEX crate will have many instruction files (new_order.rs, cancel_order.rs, etc.) and perhaps no metadata dependency, whereas a metadata-heavy NFT auction program will pull in Metaplex crates and have instructions for creating NFT vaults. By analyzing the entire set, we've linked these patterns to their sources: e.g., Draffle's Dispenser for token swaps, Pyth's test suite for governance voting, Anchor's SmartWallet for multisig, and Clockwork's plugin for off-chain integration, among others.

Overall, the Solana program repositories exhibit a strong common backbone (Anchor conventions, SPL integrations) with interesting deviations where projects push the boundaries (cross-chain logic, validator plugins, specialized financial mechanisms). This analysis, with linked references to each repo's report, provides a comprehensive view of both the norms and the novelties present in the Solana ecosystem's program development practices.
